use std::{
    fs::File,
    path::{Path, PathBuf},
};

use clap::Parser;
use frontend::{
    hyrax_worldcoin::{
        orb::IMAGE_COMMIT_LOG_NUM_COLS,
        v3::{V3CircuitAndAuxData, V3Proof},
    },
    hyrax_worldcoin_mpc::mpc_prover::{print_features_status, V3MPCCommitments},
    zk_iriscode_ss::{
        self,
        circuits::{iriscode_ss_attach_aux_data, V3_INPUT_IMAGE_LAYER, V3_SIGN_BITS_LAYER},
        io::read_bytes_from_file,
    },
};
use shared_types::{perform_function_under_expected_configs, Bn256Point, Fr};

#[cfg(feature = "print-trace")]
use tracing::Level;
#[cfg(feature = "print-trace")]
use tracing_subscriber::fmt;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct CliArguments {
    /// Path to the circuit description generated by the
    /// `world_gen_iriscode_secret_share_circuit_descriptions` binary.
    #[arg(long)]
    circuit: PathBuf,

    /// Path to the `hashes.json` file containing the commitment hashes.
    #[arg(long)]
    hashes: PathBuf,

    /// Path to the iriscode generation Hyrax proof file. Note that by default
    /// the filename is "world_v3.zkp".
    #[arg(long)]
    v3_proof: PathBuf,

    /// Path to the commitments file. Note that by default the filename is
    /// "commitments.zkp".
    #[arg(long)]
    commitments: PathBuf,
}

fn main() {
    #[cfg(feature = "print-trace")]
    let _subscriber = fmt().with_max_level(Level::DEBUG).init();

    // Sanitycheck by logging the current settings.
    perform_function_under_expected_configs!(
        print_features_status,
        &zk_iriscode_ss::EXPECTED_PROVER_CONFIG,
        &zk_iriscode_ss::EXPECTED_VERIFIER_CONFIG,
    );

    let cli = CliArguments::parse();

    perform_function_under_expected_configs!(
        verify_v3_iriscode_proof,
        &zk_iriscode_ss::EXPECTED_PROVER_CONFIG,
        &zk_iriscode_ss::EXPECTED_VERIFIER_CONFIG,
        &cli.circuit,
        &cli.hashes,
        &cli.v3_proof,
        &cli.commitments
    );
}

/// Checks that the Hyrax commitments to the {left, right} iris {mask, image}
/// are correct with respect to the Hyrax proofs of correct iriscode
/// computation. In particular, this function verifies the four Hyrax proofs
/// which prove the correctness of the following processes:
/// * {left eye, mask} --> left mask code
/// * {left eye, iris} --> left iris code
/// * {right eye, mask} --> right mask code
/// * {right eye, iris} --> right iris code
///
/// and additionally checks that the commitments to the iris/mask codes within
/// each match those given in the auxiliary commitment data.
fn verify_v3_iriscode_proof(
    path_to_circuit_description: &Path,
    path_to_hashes_json: &Path,
    path_to_v3_proof: &Path,
    path_to_aux_commitments: &Path,
) {
    println!("Verifying...");

    let serialized_circuit =
        read_bytes_from_file(path_to_circuit_description.as_os_str().to_str().unwrap());
    let v3_circuit_and_aux_data = V3CircuitAndAuxData::<Fr>::deserialize(&serialized_circuit);

    let serialized_proof = read_bytes_from_file(path_to_v3_proof.as_os_str().to_str().unwrap());
    let v3_proof = V3Proof::deserialize(&serialized_proof);

    let serialized_commitments =
        read_bytes_from_file(path_to_aux_commitments.as_os_str().to_str().unwrap());
    let v3_mpc_commitments: V3MPCCommitments<Bn256Point> =
        V3MPCCommitments::deserialize(&serialized_commitments);

    let hashes_file = File::open(path_to_hashes_json).expect("Could not open hashes.json file.");
    let parsed_hashes: serde_json::Value =
        serde_json::from_reader(hashes_file).expect("Could not parse hashes.json.");

    for is_mask in [false, true] {
        for is_left_eye in [false, true] {
            println!("Verifying combination (is_mask, is_left_eye) = ({is_mask}, {is_left_eye})");

            let eye = if is_left_eye { "left" } else { "right" };
            let iris_or_mask = if is_mask { "mask" } else { "image" };
            let commitment_hash_entry = format!("{eye}_normalized_{iris_or_mask}_commitment.bin");
            let commitment_hash = parsed_hashes
                .get(&commitment_hash_entry)
                .unwrap_or_else(|| {
                    panic!("Could not find entry {commitment_hash_entry} in hashes.json")
                })
                .as_str()
                .unwrap_or_else(|| panic!("Field {commitment_hash_entry} is not a string!"));

            let circuit = v3_circuit_and_aux_data.get_circuit();

            let aux_data = if is_mask {
                v3_circuit_and_aux_data.get_mask_aux_data_ref().clone()
            } else {
                v3_circuit_and_aux_data.get_iris_aux_data_ref().clone()
            };

            let circuit_with_inputs = iriscode_ss_attach_aux_data::<
                _,
                { frontend::zk_iriscode_ss::parameters::BASE },
            >(circuit.clone(), aux_data)
            .unwrap();

            let mut verifiable_circuit = circuit_with_inputs
                .gen_hyrax_verifiable_circuit::<Bn256Point>()
                .unwrap();

            // Use custom commitment parameters for the input layer containing the iris image.
            verifiable_circuit
                .set_commitment_parameters(V3_INPUT_IMAGE_LAYER, IMAGE_COMMIT_LOG_NUM_COLS)
                .expect("Could not modify the verifier circuit commitment parameters");

            // Add the expected commitment to iriscode as a pre-commitment, for the verifier to
            // check equality against the commitment in the proof.
            verifiable_circuit
                .set_pre_commitment(
                    V3_SIGN_BITS_LAYER,
                    v3_mpc_commitments
                        .get_code_commit_ref(is_mask, is_left_eye)
                        .clone(),
                )
                .expect("Setting pre-commitment failed.");

            if let Err(err) =
                v3_proof.verify(is_mask, is_left_eye, &verifiable_circuit, commitment_hash)
            {
                println!("IC circuit verification failed with error: {err:#?}");
            } else {
                println!("IC circuit verification succeeded!!");
            }
        }
    }
}
