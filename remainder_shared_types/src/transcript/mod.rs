//! Types for modeling and interacting with a transcript sponge when applying the
//! Fiat-Shamir transformation on a an interactive protocol.

use std::fmt::Display;

use serde::{Deserialize, Serialize};
use thiserror::Error;
use tracing::warn;

use crate::Field;

pub mod ec_transcript;
pub mod keccak_transcript;
pub mod poseidon_transcript;

pub mod counting_transcript;
pub mod test_transcript;

/// A `TranscriptSponge` provides the basic interface for a cryptographic sponge
/// operating on field elements. It is typically used for representing the
/// transcript of an interactive protocol turned non-interactive view
/// Fiat-Shamir.
pub trait TranscriptSponge<F>: Clone + Send + Sync + Default {
    /// Absorb a single field element `elem`.
    fn absorb(&mut self, elem: F);

    /// Absorb a list of field elements sequentially.
    fn absorb_elements(&mut self, elements: &[F]);

    /// Generate a field element by squeezing the sponge. Internal state is
    /// modified.
    fn squeeze(&mut self) -> F;

    /// Generate a sequence of field elements by squeezing the sponge
    /// `num_elements` times. Internal state is modified.
    fn squeeze_elements(&mut self, num_elements: usize) -> Vec<F>;
}

/// Describes an elementary operation on a transcript.
#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
enum Operation<F> {
    /// An append operation consists of a label (used for debugging purposes)
    /// and a vector of field elements to be appended in order to the
    /// transcript.
    Append(String, Vec<F>),

    /// A squeeze operation consists of a label (used for debugging purposes)
    /// and a counter of how many elements are to be squeezed from the sponge.
    Squeeze(String, usize),
}

/// A type used for storing an immutable version of the transcript.
/// A `Transcript` is typically generated by the prover using a
/// `TranscriptWriter`, and is then serialized and saved on disk as part of the
/// generated proof. The verifier de-serializes the transcript and can access it
/// through the `TranscriptReader` interface.
#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
pub struct Transcript<T> {
    /// A label used to identify this transcript. Used for debugging purposes.
    label: String,

    /// The content of the transcript represented as a sequence of operations
    /// used to generate it.
    operations: Vec<Operation<T>>,
}

impl<F: Clone> Transcript<F> {
    /// Create an empty transcript with identifier `label`.
    pub fn new(label: &str) -> Self {
        Self {
            label: String::from(label),
            operations: vec![],
        }
    }

    /// Record the operation of appending `elements` in the sponge.
    /// `label` is an identifier for this operation that can be used for sanity
    /// checking by the verifier.
    pub fn append_elements(&mut self, label: &str, elements: &[F]) {
        self.operations
            .push(Operation::Append(String::from(label), elements.to_vec()));
    }

    /// Record the operation of squeezing `num_elements` from the sponge.
    /// `label` is an identifier for this operation that can be used for sanity
    /// checking by the verifier.
    pub fn squeeze_elements(&mut self, label: &str, num_elements: usize) {
        self.operations
            .push(Operation::Squeeze(String::from(label), num_elements));
    }
}

impl<F> Display for Transcript<F> {

    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.operations.iter().try_for_each(|op| {
            match op {
                Operation::Append(label, elements) => {
                    write!(f, "Append: \"{}\" with {} elements\n", label, elements.len())
                }
                Operation::Squeeze(label, num_elements) => {
                    write!(f, "Squeeze: \"{}\" with {} elements\n", label, num_elements)
                }
            }
        })
    }
}

pub trait ProverTranscript<F> {
    fn append(&mut self, label: &str, elem: F);

    fn append_elements(&mut self, label: &str, elements: &[F]);

    fn get_challenge(&mut self, label: &str) -> F;

    fn get_challenges(&mut self, label: &str, num_elements: usize) -> Vec<F>;
}

/// The prover-side interface for interacting with a transcript sponge. A
/// `TranscriptWriter` acts as a wrapper around a `TranscriptSponge` and
/// additionally keeps track of all the append/squeeze operations to be able to
/// generate a serializable `Transcript`.
pub struct TranscriptWriter<F, T> {
    /// The sponge that this writer is using to append/squeeze elements.
    sponge: T,

    /// A mutable transcript which keeps a record of all the append/squeeze
    /// operations.
    transcript: Transcript<F>,
}

impl<F: Field, Tr: TranscriptSponge<F>> ProverTranscript<F> for TranscriptWriter<F, Tr> {
    /// Append an element to the sponge and record the operation to the
    /// transcript. `label` is an identifier for this operation and is used for
    /// sanity checking by the `TranscriptReader`.
    fn append(&mut self, label: &str, elem: F) {
        self.sponge.absorb(elem);
        self.transcript.append_elements(label, &[elem]);
    }

    /// Append a slice of elements to the sponge sequentially and record the
    /// operation on the transcript. If `elements` is the empty slice, the
    /// operation is *not* recorded.
    /// `label` is an identifier for this operation
    /// and is used for sanity checking by the `TranscriptReader`.
    fn append_elements(&mut self, label: &str, elements: &[F]) {
        if !elements.is_empty() {
            self.sponge.absorb_elements(elements);
            self.transcript.append_elements(label, elements);
        }
    }

    /// Squeezes the sponge once to get an element and records the squeeze
    /// operation on the transcript.
    /// `label` serves as sanity-check identifier by the `TranscriptReader`.
    fn get_challenge(&mut self, label: &str) -> F {
        let challenge = self.sponge.squeeze();
        self.transcript.squeeze_elements(label, 1);
        challenge
    }

    /// Squeezes the sponge `num_elements` times to get a sequence of elements
    /// and records the operation on the transcript. If `num_elements == 0`, the
    /// empty vector is returned and the operation is *not* recorded on the
    /// transcript.
    /// `label` serves as sanity-check identifier by the `TranscriptReader`.
    fn get_challenges(&mut self, label: &str, num_elements: usize) -> Vec<F> {
        if num_elements == 0 {
            vec![]
        } else {
            let challenges = self.sponge.squeeze_elements(num_elements);
            self.transcript.squeeze_elements(label, num_elements);
            challenges
        }
    }
}

impl<F: Field, Tr: TranscriptSponge<F>> TranscriptWriter<F, Tr> {
    /// Destructively extract the transcript produced by this writer.
    /// This should be the last operation performed on a `TranscriptWriter`.
    pub fn get_transcript(self) -> Transcript<F> {
        self.transcript
    }

    /// Creates an empty sponge.
    /// `label` is an identifier used for debugging purposes.
    pub fn new(label: &str) -> Self {
        Self {
            sponge: Tr::default(),
            transcript: Transcript::new(label),
        }
    }
}

pub trait VerifierTranscript<F> {
    fn consume_element(&mut self, label: &'static str) -> Result<F, TranscriptReaderError>;

    fn consume_elements(
        &mut self,
        label: &'static str,
        num_elements: usize,
    ) -> Result<Vec<F>, TranscriptReaderError>;

    fn get_challenge(&mut self, label: &'static str) -> Result<F, TranscriptReaderError>;

    fn get_challenges(
        &mut self,
        label: &'static str,
        num_elements: usize,
    ) -> Result<Vec<F>, TranscriptReaderError>;
}

/// Errors that a `TranscriptReader` may produce.
#[derive(Error, Debug, Clone, PartialEq)]
pub enum TranscriptReaderError {
    #[error("An unexpected consume operation was requested")]
    ConsumeError,
    #[error("An unexpected squeeze operation was requested")]
    SqueezeError,
}

/// A `TranscriptReader` is typically created using a `Transcript` produced by a
/// `TranscriptWriter`.
///
/// Its operation is similar to that of the writer, except that instead of an
/// "append" operation, it provides a "consume" operation which returns the next
/// field element that was appended to the circuit by the prover. The user of a
/// `TranscriptReader` (typically that is the verifier) is responsible for
/// running any checks (if necessary) to verify the validity of the consumed
/// elements. The "squeeze" operation behaves similarly to that of a
/// `TranscriptWriter`.
///
/// Consume/Squeeze operations on a `TranscriptReader` may return errors when an
/// unexpected operation is requested. An operation can be unexpected if it
/// doesn't match the sequence of operations performed by the `TranscriptWriter`
/// that produced the `Transcript` used in the initialization of the reader.
pub struct TranscriptReader<F, T> {
    /// The sponge that this reader is wrapping around.
    sponge: T,

    /// The transcript that this reader is using to consume elements from and
    /// verify the order of operations is valid.
    transcript: Transcript<F>,

    /// An internal state representing the position of the next operation on the
    /// transcript.
    next_element: (usize, usize),
}

impl<F: Field, T: TranscriptSponge<F>> VerifierTranscript<F> for TranscriptReader<F, T> {
    /// Reads off a single element from the transcript and returns it if
    /// successful.
    /// The operation can fail with:
    /// * `TranscriptReaderError::ConsumeError`: if there are no more elements
    ///   to consume or if a squeeze was expected.
    ///
    /// The `label` is used for sanity checking against the label that was used
    /// by the `TranscriptWriter` for the corresponding operation. If the labels
    /// don't match, a trace warning message is produced, but the caller is not
    /// otherwise notified of this discrepancy.
    fn consume_element(&mut self, label: &'static str) -> Result<F, TranscriptReaderError> {
        let (operation_idx, element_idx) = self.next_element;

        match self.transcript.operations.get(operation_idx) {
            None => Err(TranscriptReaderError::ConsumeError),
            Some(Operation::Squeeze(_, _)) => Err(TranscriptReaderError::ConsumeError),
            Some(Operation::Append(expected_label, v)) => {
                if label != expected_label {
                    warn!("Label mismatch on TranscriptReader consume_element. Expected \"{}\" but instead got \"{}\".", expected_label, label);
                }
                match v.get(element_idx) {
                    None => {
                        // This should never happen if `self.advance_indices()` maintains its
                        // invariants. Panicking because we reached an inconsistent state.
                        panic!("Internal TranscriptReader Error: indices are in an inconsistent state!");
                    }
                    Some(&element) => {
                        self.advance_indices()?;
                        self.sponge.absorb(element);
                        Ok(element)
                    }
                }
            }
        }
    }

    /// A multi-element version of the `consume_element` method. Reads off a
    /// sequence of `num_elements` elements from the transcript and returns a
    /// vector of them if successful.
    /// The operation can fail with:
    /// * `TranscriptReaderError::ConsumeError`: if less than `num_elements`
    ///   elements remain in the transcript or if a squeeze operation was
    ///   expected to occur at any point before the consumption of
    ///   `num_elements` elements.
    ///
    /// The `label` is used for sanity checking against the label that was used
    /// by the `TranscriptWriter` for the corresponding operations. In
    /// particular, the `TranscriptWriter` may have appended either a sequence
    /// of elements using `TranscriptWritter::append_elements` or may have
    /// called `TranscriptWritter::append` multiple times. Both scenarios are
    /// valid and in both cases, `label` should match with the corresponding
    /// labels used on the writer side. If there is a label mismatch for any of
    /// the `num_elements` elements, a trace warning message is produced, but
    /// the caller is not otherwise notified of this discrepancy.
    fn consume_elements(
        &mut self,
        label: &'static str,
        num_elements: usize,
    ) -> Result<Vec<F>, TranscriptReaderError> {
        (0..num_elements)
            .map(|_| self.consume_element(label))
            .collect()
    }

    /// Squeezes the sponge once and returns a single element if successful.
    /// The operation can fail with:
    /// * `TranscriptReaderError::SqueezeError`: if a squeeze is requested at a
    ///   time when either a consume operation was expected or no more
    ///   operations were expected.
    ///
    /// The `label` is used for sanity checking against the label that was used
    /// by the `TranscriptWriter` for the corresponding operation. If the labels
    /// don't match, a trace warning message is produced, but the caller is not
    /// otherwise notified of this discrepancy.
    fn get_challenge(&mut self, label: &'static str) -> Result<F, TranscriptReaderError> {
        let (operation_idx, element_idx) = self.next_element;

        match self.transcript.operations.get(operation_idx) {
            None => Err(TranscriptReaderError::SqueezeError),
            Some(Operation::Append(_, _)) => Err(TranscriptReaderError::SqueezeError),
            Some(Operation::Squeeze(expected_label, num_elements)) => {
                if label != expected_label {
                    warn!("Label mismatch on TranscriptReader get_challenge. Expected \"{}\" but instead got \"{}\".", expected_label, label);
                }
                if element_idx >= *num_elements {
                    Err(TranscriptReaderError::SqueezeError)
                } else {
                    self.advance_indices()?;
                    Ok(self.sponge.squeeze())
                }
            }
        }
    }

    /// Squeezes the sponge `num_elements` times and returns a vector of the
    /// resulting elements if successful.
    /// The operation can fail with:
    /// * `TranscriptReaderError::SqueezeError`: if any of the squeeze
    ///   operations requested does not correspond to a squeeze operation
    ///   performed by the `TranscriptWriter` that produced the transcript.
    ///
    /// The `label` is used for sanity checking against the label that was used
    /// by the `TranscriptWriter` for the corresponding operations. In
    /// particular, the `TranscriptWriter` may have squeezed either a sequence
    /// of elements using `TranscriptWriter::get_challenges` or may have called
    /// `TranscriptWriter::get_challenge` multiple times. Both scenarios are
    /// valid and in both cases, `label` should match with the corresponding
    /// labels used on the writer side. If there is a label mismatch for any of
    /// the `num_elements` elements, a trace warning message is produced, but
    /// the caller is not otherwise notified of this discrepancy.
    fn get_challenges(
        &mut self,
        label: &'static str,
        num_elements: usize,
    ) -> Result<Vec<F>, TranscriptReaderError> {
        (0..num_elements)
            .map(|_| self.get_challenge(label))
            .collect()
    }
}

impl<F: std::fmt::Debug, T: Default> TranscriptReader<F, T> {
    /// Generate a new `TranscriptReader` to operate on a given `transcript`.
    pub fn new(transcript: Transcript<F>) -> Self {
        Self {
            sponge: T::default(),
            transcript,
            next_element: (0, 0),
        }
    }

    /// Internal method used to advance the internal state to the next
    /// operation.
    fn advance_indices(&mut self) -> Result<(), TranscriptReaderError> {
        let (operation_idx, element_idx) = self.next_element;

        match self.transcript.operations.get(operation_idx) {
            None => {
                // `advance_indices` should never be called in an already inconsistent state.
                panic!("Internal TranscriptReader Error: attempt to advance indices in an already inconsistent state!");
            }
            Some(Operation::Append(_, v)) => {
                if element_idx + 1 >= v.len() {
                    self.next_element = (operation_idx + 1, 0);
                } else {
                    self.next_element = (operation_idx, element_idx + 1);
                }
                Ok(())
            }
            Some(Operation::Squeeze(_, num_elements)) => {
                if element_idx + 1 >= *num_elements {
                    self.next_element = (operation_idx + 1, 0);
                } else {
                    self.next_element = (operation_idx, element_idx + 1);
                }
                Ok(())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use self::poseidon_transcript::PoseidonSponge;

    use super::*;
    use crate::Fr;

    fn generate_test_transcript() -> Transcript<Fr> {
        let mut transcript_writer = TranscriptWriter::<Fr, PoseidonSponge<Fr>>::new("New tw");

        transcript_writer.append("A1", Fr::from(1));
        transcript_writer.append("A2", Fr::from(2));
        let _ = transcript_writer.get_challenge("C1");
        transcript_writer.append_elements("A3", &[Fr::from(3), Fr::from(4)]);
        // The following operation should be ignored.
        transcript_writer.append_elements("A3*", &[]);
        transcript_writer.append("A4", Fr::from(5));
        let _ = transcript_writer.get_challenge("C2");
        let _ = transcript_writer.get_challenges("C3", 5);
        // The following operation should be ignored.
        let _ = transcript_writer.get_challenges("C3*", 0);
        transcript_writer.append_elements("A5", &[Fr::from(6), Fr::from(7), Fr::from(8)]);
        let _ = transcript_writer.get_challenge("C4");

        transcript_writer.get_transcript()
    }

    #[test]
    fn test_transcript_writer_internal_state() {
        let transcript = generate_test_transcript();

        let appended_elements = vec![
            Operation::Append(String::from("A1"), vec![Fr::from(1)]),
            Operation::Append(String::from("A2"), vec![Fr::from(2)]),
            Operation::Squeeze(String::from("C1"), 1),
            Operation::Append(String::from("A3"), vec![Fr::from(3), Fr::from(4)]),
            Operation::Append(String::from("A4"), vec![Fr::from(5)]),
            Operation::Squeeze(String::from("C2"), 1),
            Operation::Squeeze(String::from("C3"), 5),
            Operation::Append(
                String::from("A5"),
                vec![Fr::from(6), Fr::from(7), Fr::from(8)],
            ),
            Operation::Squeeze(String::from("C4"), 1),
        ];

        let expected_transcript = Transcript::<Fr> {
            label: String::from("New tw"),
            operations: appended_elements,
        };

        assert_eq!(transcript, expected_transcript);
    }

    #[test]
    fn test_transcript_reader() {
        let transcript = generate_test_transcript();
        let mut transcript_reader = TranscriptReader::<Fr, PoseidonSponge<Fr>>::new(transcript);

        assert_eq!(
            transcript_reader.consume_element("A1").unwrap(),
            Fr::from(1)
        );
        assert_eq!(
            transcript_reader.consume_element("A2").unwrap(),
            Fr::from(2)
        );
        assert!(transcript_reader.get_challenge("C1").is_ok());
        assert_eq!(
            transcript_reader.consume_element("A3").unwrap(),
            Fr::from(3)
        );
        assert_eq!(
            transcript_reader.consume_element("A3").unwrap(),
            Fr::from(4)
        );
        assert_eq!(
            transcript_reader.consume_element("A4").unwrap(),
            Fr::from(5)
        );
        assert!(transcript_reader.get_challenge("C2").is_ok());
        assert!(transcript_reader.get_challenges("C3", 5).is_ok());
        assert_eq!(
            transcript_reader.consume_element("A5").unwrap(),
            Fr::from(6)
        );
        assert_eq!(
            transcript_reader.consume_element("A5").unwrap(),
            Fr::from(7)
        );
        assert_eq!(
            transcript_reader.consume_element("A5").unwrap(),
            Fr::from(8)
        );
        assert!(transcript_reader.get_challenge("C4").is_ok());

        assert!(transcript_reader.get_challenge("C5").is_err());
        assert!(transcript_reader.consume_element("A6").is_err());
    }
}
