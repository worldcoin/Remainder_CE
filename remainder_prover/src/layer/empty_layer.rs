//!A Layer with 0 num_vars

use std::marker::PhantomData;

use crate::{
    expression::{
        generic_expr::{Expression, ExpressionNode},
        prover_expr::ProverExpr,
    },
    mle::{beta::BetaTable, dense::DenseMleRef, mle_enum::MleEnum, MleRef},
    prover::SumcheckProof,
    sumcheck::{evaluate_at_a_point, get_round_degree, Evals},
};
use ark_std::cfg_into_iter;
use rayon::{iter::IntoParallelIterator, prelude::ParallelIterator};
use remainder_shared_types::{transcript::Transcript, FieldExt};
use serde::{Deserialize, Serialize};

use super::{
    claims::{Claim, ClaimError},
    layer_enum::LayerEnum,
    Layer, LayerError, LayerId,
};

///A Layer with 0 num_vars
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(bound = "F: FieldExt")]
pub struct EmptyLayer<F: FieldExt, Tr> {
    pub(crate) expr: Expression<F, ProverExpr>,
    id: LayerId,
    _marker: PhantomData<Tr>,
}

impl<F: FieldExt, Tr: Transcript<F>> Layer<F> for EmptyLayer<F, Tr> {
    type Transcript = Tr;

    fn prove_rounds(
        &mut self,
        _: Claim<F>,
        _: &mut Self::Transcript,
    ) -> Result<SumcheckProof<F>, LayerError> {
        let eval = self
            .expr
            .clone()
            .transform_to_verifier_expression()
            .unwrap()
            .gather_combine_all_evals()
            .map_err(LayerError::ExpressionError)?;

        Ok(Some(vec![vec![eval]]).into())
    }

    fn verify_rounds(
        &mut self,
        claim: Claim<F>,
        sumcheck_rounds: Option<Vec<Vec<F>>>,
        _: &mut Self::Transcript,
    ) -> Result<(), LayerError> {
        if sumcheck_rounds.is_none() {
            Ok(())
        } else {
            let sumcheck_rounds = sumcheck_rounds.unwrap();
            if sumcheck_rounds[0][0] != claim.get_result() {
                return Err(LayerError::VerificationError(
                    super::VerificationError::GKRClaimCheckFailed,
                ));
            }
            Ok(())
        }
    }

    fn get_enum(self) -> LayerEnum<F, Tr> {
        LayerEnum::EmptyLayer(self)
    }

    fn get_claims(&self) -> Result<Vec<Claim<F>>, LayerError> {
        // First off, parse the expression that is associated with the layer...
        // Next, get to the actual claims that are generated by each expression and grab them
        // Return basically a list of (usize, Claim)
        let layerwise_expr = self.expression();

        // --- Define how to parse the expression tree ---
        // - Basically we just want to go down it and pass up claims
        // - We can only add a new claim if we see an MLE with all its indices bound

        let mut claims: Vec<Claim<F>> = Vec::new();

        let mut observer_fn = |exp_node: &ExpressionNode<F, ProverExpr>,
                               mle_vec: &Vec<DenseMleRef<F>>| {
            match exp_node {
                ExpressionNode::Mle(mle_vec_idx) => {
                    let mle_ref = mle_vec_idx.get_mle(mle_vec);

                    // --- First ensure that all the indices are fixed ---
                    let mle_indices = mle_ref.mle_indices();

                    // --- This is super jank ---
                    let mut fixed_mle_indices: Vec<F> = vec![];
                    for mle_idx in mle_indices {
                        fixed_mle_indices.push(mle_idx.val().ok_or(ClaimError::MleRefMleError)?);
                    }

                    // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                    let mle_layer_id = mle_ref.get_layer_id();

                    // --- Grab the actual value that the claim is supposed to evaluate to ---
                    if mle_ref.bookkeeping_table().len() != 1 {
                        return Err(ClaimError::MleRefMleError);
                    }
                    let claimed_value = mle_ref.bookkeeping_table()[0];

                    // --- Construct the claim ---
                    let claim: Claim<F> = Claim::new(
                        fixed_mle_indices,
                        claimed_value,
                        Some(self.id().clone()),
                        Some(mle_layer_id),
                        Some(MleEnum::Dense(mle_ref.clone())),
                    );

                    // --- Push it into the list of claims ---
                    // --- Also push the layer_id ---
                    claims.push(claim);
                }
                ExpressionNode::Product(mle_vec_indices) => {
                    for mle_vec_index in mle_vec_indices {
                        // --- First ensure that all the indices are fixed ---
                        let mle_ref = mle_vec_index.get_mle(mle_vec);

                        let mle_indices = mle_ref.mle_indices();

                        // --- This is super jank ---
                        let mut fixed_mle_indices: Vec<F> = vec![];
                        for mle_idx in mle_indices {
                            fixed_mle_indices
                                .push(mle_idx.val().ok_or(ClaimError::MleRefMleError)?);
                        }

                        // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                        let mle_layer_id = mle_ref.get_layer_id();

                        // --- Grab the actual value that the claim is supposed to evaluate to ---
                        if mle_ref.bookkeeping_table().len() != 1 {
                            return Err(ClaimError::MleRefMleError);
                        }
                        let claimed_value = mle_ref.bookkeeping_table()[0];

                        // --- Construct the claim ---
                        let claim: Claim<F> = Claim::new(
                            fixed_mle_indices,
                            claimed_value,
                            Some(self.id().clone()),
                            Some(mle_layer_id),
                            Some(MleEnum::Dense(mle_ref.clone())),
                        );

                        // --- Push it into the list of claims ---
                        // --- Also push the layer_id ---
                        claims.push(claim);
                    }
                }
                _ => {}
            }
            Ok(())
        };

        // TODO!(ryancao): What the heck is this code doing?
        layerwise_expr
            .traverse(&mut observer_fn)
            .map_err(LayerError::ClaimError)?;

        Ok(claims)
    }

    fn id(&self) -> &LayerId {
        &self.id
    }

    fn get_wlx_evaluations(
        &self,
        claim_vecs: &Vec<Vec<F>>,
        claimed_vals: &Vec<F>,
        claim_mle_refs: Vec<MleEnum<F>>,
        num_claims: usize,
        num_idx: usize,
    ) -> Result<Vec<F>, ClaimError> {
        unimplemented!()
    }

    fn new<L: super::LayerBuilder<F>>(builder: L, id: LayerId) -> Self
    where
        Self: Sized,
    {
        Self {
            id,
            expr: builder.build_expression(),
            _marker: PhantomData,
        }
    }
}

impl<F: FieldExt, Tr: Transcript<F>> EmptyLayer<F, Tr> {
    ///Gets this layer's underlying expression
    pub fn expression(&self) -> &Expression<F, ProverExpr> {
        &self.expr
    }

    pub(crate) fn new_raw(id: LayerId, expr: Expression<F, ProverExpr>) -> Self {
        Self {
            id,
            expr,
            _marker: PhantomData,
        }
    }
}
