use ark_std::cfg_into_iter;
use remainder_shared_types::Field;

use crate::layer::Layer;
use crate::{
    claims::{
        wlx_eval::{get_num_wlx_evaluations, ClaimMle, YieldWLXEvals},
        ClaimError, YieldClaim,
    },
    expression::{
        generic_expr::{ExpressionNode, ExpressionType},
        prover_expr::ProverExpr,
        verifier_expr::VerifierExpr,
    },
    layer::{
        combine_mle_refs::{combine_mle_refs_with_aggregate, pre_fix_mle_refs},
        LayerError, VerifierLayer,
    },
    mle::dense::DenseMle,
    sumcheck::evaluate_at_a_point,
};

use crate::mle::Mle;

use super::{RegularLayer, VerifierRegularLayer};
#[cfg(feature = "parallel")]
use rayon::iter::{IntoParallelIterator, ParallelIterator};

/// A flag representing whether we are using the constant
/// column optimization for claim aggregation.
pub const CLAIM_AGGREGATION_CONSTANT_COLUMN_OPTIMIZATION: bool = false;

impl<F: Field> YieldClaim<ClaimMle<F>> for RegularLayer<F> {
    fn get_claims(&self) -> Result<Vec<ClaimMle<F>>, LayerError> {
        // First off, parse the expression that is associated with the layer...
        // Next, get to the actual claims that are generated by each expression and grab them
        // Return basically a list of (usize, Claim)
        let layerwise_expr = &self.expression;

        // --- Define how to parse the expression tree ---
        // - Basically we just want to go down it and pass up claims
        // - We can only add a new claim if we see an MLE with all its indices bound

        let mut claims: Vec<ClaimMle<F>> = Vec::new();

        let mut observer_fn =
            |exp: &ExpressionNode<F, ProverExpr>,
             mle_vec: &<ProverExpr as ExpressionType<F>>::MleVec| {
                match exp {
                    ExpressionNode::Mle(mle_vec_idx) => {
                        let mle_ref = mle_vec_idx.get_mle(mle_vec);

                        let fixed_mle_indices = mle_ref
                            .mle_indices
                            .iter()
                            .map(|index| index.val().ok_or(ClaimError::MleRefMleError))
                            .collect::<Result<Vec<_>, _>>()?;

                        // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                        let mle_layer_id = mle_ref.get_layer_id();

                        // --- Grab the actual value that the claim is supposed to evaluate to ---
                        if mle_ref.bookkeeping_table().len() > 1 {
                            return Err(ClaimError::MleRefMleError);
                        }
                        if mle_ref.bookkeeping_table().is_empty() {
                            return Err(ClaimError::IntermediateZeroMLERefError);
                        }
                        let claimed_value = mle_ref.bookkeeping_table()[0];

                        // Note: No need to append claim values here.
                        // We already appended them when evaluating the
                        // expression for sumcheck.

                        // --- Construct the claim ---
                        let claim: ClaimMle<F> = ClaimMle::new(
                            fixed_mle_indices,
                            claimed_value,
                            Some(self.layer_id()),
                            Some(mle_layer_id),
                        );

                        // --- Push it into the list of claims ---
                        claims.push(claim);
                    }
                    ExpressionNode::Product(mle_vec_indices) => {
                        for mle_vec_index in mle_vec_indices {
                            let mle_ref = mle_vec_index.get_mle(mle_vec);
                            let fixed_mle_indices = mle_ref
                                .mle_indices
                                .iter()
                                .map(|index| index.val().ok_or(ClaimError::MleRefMleError))
                                .collect::<Result<Vec<_>, _>>()?;

                            // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                            let mle_layer_id = mle_ref.get_layer_id();

                            // --- Grab the actual value that the claim is supposed to evaluate to ---
                            if mle_ref.bookkeeping_table().len() != 1 {
                                return Err(ClaimError::MleRefMleError);
                            }
                            let claimed_value = mle_ref.bookkeeping_table()[0];

                            // Note: No need to append the claim value to the transcript here. We
                            // already appended when evaluating the expression for sumcheck.

                            // --- Construct the claim ---
                            // need to populate the claim with the mle ref we are grabbing the claim from
                            let claim: ClaimMle<F> = ClaimMle::new(
                                fixed_mle_indices,
                                claimed_value,
                                Some(self.layer_id()),
                                Some(mle_layer_id),
                            );

                            // --- Push it into the list of claims ---
                            claims.push(claim);
                        }
                    }
                    _ => {}
                }
                Ok(())
            };

        // --- Apply the observer function from above onto the expression ---
        layerwise_expr.traverse(&mut observer_fn)?;

        Ok(claims)
    }
}

impl<F: Field> YieldWLXEvals<F> for RegularLayer<F> {
    fn get_wlx_evaluations(
        &self,
        claim_vecs: &[Vec<F>],
        claimed_vals: &[F],
        claim_mle_refs: Vec<DenseMle<F>>,
        num_claims: usize,
        num_idx: usize,
    ) -> Result<Vec<F>, ClaimError> {
        // get the number of evaluations

        let (num_evals, common_idx) = if CLAIM_AGGREGATION_CONSTANT_COLUMN_OPTIMIZATION {
            let (num_evals, common_idx, _) = get_num_wlx_evaluations(claim_vecs);
            (num_evals, common_idx)
        } else {
            assert!(claim_vecs.len() > 1);
            (((num_claims - 1) * num_idx) + 1, None)
        };

        let mut claim_mle_refs = claim_mle_refs;

        if let Some(common_idx) = common_idx {
            pre_fix_mle_refs(&mut claim_mle_refs, &claim_vecs[0], common_idx);
        }

        // we already have the first #claims evaluations, get the next num_evals - #claims evaluations
        let next_evals: Vec<F> = cfg_into_iter!(num_claims..num_evals)
            .map(|idx| {
                // get the challenge l(idx)
                let new_chal: Vec<F> = cfg_into_iter!(0..num_idx)
                    .map(|claim_idx| {
                        let evals: Vec<F> = cfg_into_iter!(claim_vecs)
                            .map(|claim| claim[claim_idx])
                            .collect();
                        evaluate_at_a_point(&evals, F::from(idx as u64)).unwrap()
                    })
                    .collect();

                let wlx_eval_on_mle_ref =
                    combine_mle_refs_with_aggregate(&claim_mle_refs, &new_chal);
                wlx_eval_on_mle_ref.unwrap()
            })
            .collect();

        // concat this with the first k evaluations from the claims to
        // get num_evals evaluations
        let mut wlx_evals = claimed_vals.to_vec();
        wlx_evals.extend(&next_evals);
        Ok(wlx_evals)
    }
}

impl<F: Field> YieldClaim<ClaimMle<F>> for VerifierRegularLayer<F> {
    fn get_claims(&self) -> Result<Vec<ClaimMle<F>>, LayerError> {
        let expr = &self.expression;

        // --- Define how to parse the expression tree ---
        // - Basically we just want to go down it and pass up claims
        // - We can only add a new claim if we see an MLE with all its indices bound

        let mut claims: Vec<ClaimMle<F>> = Vec::new();

        let mut observer_fn = |exp: &ExpressionNode<F, VerifierExpr>,
                               _mle_vec: &<VerifierExpr as ExpressionType<F>>::MleVec|
         -> Result<(), LayerError> {
            match exp {
                ExpressionNode::Mle(verifier_mle) => {
                    let fixed_mle_indices = verifier_mle
                        .mle_indices()
                        .iter()
                        .map(|index| index.val().ok_or(ClaimError::MleRefMleError))
                        .collect::<Result<Vec<_>, _>>()?;

                    // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                    let mle_layer_id = verifier_mle.layer_id();

                    // --- Grab the actual value that the claim is supposed to evaluate to ---
                    let claimed_value = verifier_mle.value();

                    // --- Construct the claim ---
                    let claim: ClaimMle<F> = ClaimMle::new(
                        fixed_mle_indices,
                        claimed_value,
                        Some(self.layer_id()),
                        Some(mle_layer_id),
                    );

                    // --- Push it into the list of claims ---
                    claims.push(claim);
                }
                ExpressionNode::Product(verifier_mle_vec) => {
                    for verifier_mle in verifier_mle_vec {
                        let fixed_mle_indices = verifier_mle
                            .mle_indices()
                            .iter()
                            .map(|index| index.val().ok_or(ClaimError::MleRefMleError))
                            .collect::<Result<Vec<_>, _>>()?;

                        // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                        let mle_layer_id = verifier_mle.layer_id();

                        let claimed_value = verifier_mle.value();

                        // --- Construct the claim ---
                        let claim: ClaimMle<F> = ClaimMle::new(
                            fixed_mle_indices,
                            claimed_value,
                            Some(self.layer_id()),
                            Some(mle_layer_id),
                        );

                        // --- Push it into the list of claims ---
                        claims.push(claim);
                    }
                }
                _ => {}
            }
            Ok(())
        };

        // --- Apply the observer function from above onto the expression ---
        expr.traverse(&mut observer_fn)?;

        Ok(claims)
    }
}
