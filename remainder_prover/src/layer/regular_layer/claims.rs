use ark_std::cfg_into_iter;
use rayon::prelude::{IntoParallelIterator, ParallelIterator};
use remainder_shared_types::{layer::Layer, FieldExt};

use crate::{
    claims::{
        wlx_eval::{get_num_wlx_evaluations, ClaimMle, YieldWLXEvals},
        ClaimError, YieldClaim,
    },
    expression::{
        generic_expr::{ExpressionNode, ExpressionType},
        prover_expr::ProverExpr,
    },
    layer::{
        combine_mle_refs::{combine_mle_refs_with_aggregate, pre_fix_mle_refs},
        LayerError,
    },
    mle::mle_enum::MleEnum,
    sumcheck::evaluate_at_a_point,
};

use crate::mle::Mle;

use super::RegularLayer;

impl<F: FieldExt> YieldClaim<ClaimMle<F>> for RegularLayer<F> {
    fn get_claims(&self) -> Result<Vec<ClaimMle<F>>, LayerError> {
        // First off, parse the expression that is associated with the layer...
        // Next, get to the actual claims that are generated by each expression and grab them
        // Return basically a list of (usize, Claim)
        let layerwise_expr = &self.expression;

        // --- Define how to parse the expression tree ---
        // - Basically we just want to go down it and pass up claims
        // - We can only add a new claim if we see an MLE with all its indices bound

        let mut claims: Vec<ClaimMle<F>> = Vec::new();

        let mut observer_fn =
            |exp: &ExpressionNode<F, ProverExpr>,
             mle_vec: &<ProverExpr as ExpressionType<F>>::MleVec| {
                match exp {
                    ExpressionNode::Mle(mle_vec_idx) => {
                        let mle_ref = mle_vec_idx.get_mle(mle_vec);

                        let fixed_mle_indices = mle_ref
                            .mle_indices
                            .iter()
                            .map(|index| index.val().ok_or(ClaimError::MleRefMleError))
                            .collect::<Result<Vec<_>, _>>()?;

                        // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                        let mle_layer_id = mle_ref.get_layer_id();

                        // --- Grab the actual value that the claim is supposed to evaluate to ---
                        if mle_ref.bookkeeping_table().len() != 1 {
                            return Err(ClaimError::MleRefMleError);
                        }
                        let claimed_value = mle_ref.bookkeeping_table()[0];

                        // --- Construct the claim ---
                        let claim: ClaimMle<F> = ClaimMle::new(
                            fixed_mle_indices,
                            claimed_value,
                            Some(*self.id()),
                            Some(mle_layer_id),
                            Some(MleEnum::Dense(mle_ref.clone())),
                        );

                        // --- Push it into the list of claims ---
                        claims.push(claim);
                    }
                    ExpressionNode::Product(mle_vec_indices) => {
                        for mle_vec_index in mle_vec_indices {
                            let mle_ref = mle_vec_index.get_mle(mle_vec);

                            let fixed_mle_indices = mle_ref
                                .mle_indices
                                .iter()
                                .map(|index| index.val().ok_or(ClaimError::MleRefMleError))
                                .collect::<Result<Vec<_>, _>>()?;

                            // --- Grab the layer ID (i.e. MLE index) which this mle_ref refers to ---
                            let mle_layer_id = mle_ref.get_layer_id();

                            // --- Grab the actual value that the claim is supposed to evaluate to ---

                            if mle_ref.bookkeeping_table().len() != 1 {
                                return Err(ClaimError::MleRefMleError);
                            }
                            let claimed_value = mle_ref.bookkeeping_table()[0];

                            // --- Construct the claim ---
                            // need to populate the claim with the mle ref we are grabbing the claim from
                            let claim: ClaimMle<F> = ClaimMle::new(
                                fixed_mle_indices,
                                claimed_value,
                                Some(*self.id()),
                                Some(mle_layer_id),
                                Some(MleEnum::Dense(mle_ref.clone())),
                            );

                            // --- Push it into the list of claims ---
                            claims.push(claim);
                        }
                    }
                    _ => {}
                }
                Ok(())
            };

        // --- Apply the observer function from above onto the expression ---
        layerwise_expr.traverse(&mut observer_fn)?;

        Ok(claims)
    }
}

impl<F: FieldExt> YieldWLXEvals<F> for RegularLayer<F> {
    fn get_wlx_evaluations(
        &self,
        claim_vecs: &[Vec<F>],
        claimed_vals: &[F],
        claim_mle_refs: Vec<MleEnum<F>>,
        num_claims: usize,
        num_idx: usize,
    ) -> Result<Vec<F>, ClaimError> {
        // get the number of evaluations
        let (num_evals, common_idx) = get_num_wlx_evaluations(claim_vecs);

        let mut claim_mle_refs = claim_mle_refs;

        if let Some(common_idx) = common_idx {
            pre_fix_mle_refs(&mut claim_mle_refs, &claim_vecs[0], common_idx);
        }

        // we already have the first #claims evaluations, get the next num_evals - #claims evaluations
        let next_evals: Vec<F> = cfg_into_iter!(num_claims..num_evals)
            .map(|idx| {
                // get the challenge l(idx)
                let new_chal: Vec<F> = cfg_into_iter!(0..num_idx)
                    .map(|claim_idx| {
                        let evals: Vec<F> = cfg_into_iter!(claim_vecs)
                            .map(|claim| claim[claim_idx])
                            .collect();
                        evaluate_at_a_point(&evals, F::from(idx as u64)).unwrap()
                    })
                    .collect();

                let wlx_eval_on_mle_ref =
                    combine_mle_refs_with_aggregate(&claim_mle_refs, &new_chal);
                wlx_eval_on_mle_ref.unwrap()
            })
            .collect();

        // concat this with the first k evaluations from the claims to
        // get num_evals evaluations
        let mut wlx_evals = claimed_vals.to_vec();
        wlx_evals.extend(&next_evals);
        Ok(wlx_evals)
    }
}
