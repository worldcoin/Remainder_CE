use crate::ligero_ml_helper::get_ml_inner_outer_tensors;
use crate::ligero_structs::{LigeroAuxInfo, LigeroCommit, LigeroRoot};
use crate::Field;
use crate::{verify, ProverError};
use remainder_shared_types::transcript::ProverTranscript;
use remainder_shared_types::transcript::VerifierTranscript;
use tracing::instrument;

use super::poseidon_ligero::PoseidonSpongeHasher;
use super::{commit, prove};

/// API for Remainder's Ligero commitment. Note that this function automatically
/// picks the Ligero matrix size, and that [PoseidonSpongeHasher] is automatically used as
/// the hasher of choice.
///
/// ## Arguments
///
/// * `input_mle_bookkeeping_table` - bookkeeping table for the combined input MLE
/// * `rho_inv` - The Ligero code rate
/// * `ratio` - The Ligero unencoded matrix ratio
///
/// ## Returns
///
/// * `ligero_encoding` - Not useful; can be reconstructed from the eval proof
/// * `ligero_commit` - Commitment including encoded matrix
/// * `ligero_root` - Merkle tree root
/// * `aux` - Auxiliary info for Ligero
#[instrument(skip_all, level = "debug")]
pub fn remainder_ligero_commit<F: Field>(
    input_mle_bookkeeping_table: &[F],
    aux: &LigeroAuxInfo<F>,
) -> (LigeroCommit<PoseidonSpongeHasher<F>, F>, LigeroRoot<F>) {
    // Sanitycheck
    assert!(input_mle_bookkeeping_table.len().is_power_of_two());

    // Create commitment
    let comm =
        commit::<PoseidonSpongeHasher<F>, LigeroAuxInfo<F>, F>(input_mle_bookkeeping_table, aux)
            .unwrap();

    // Only component of commitment which needs to be sent to the verifier is the commitment root
    let root: LigeroRoot<F> = comm.get_root();

    // Return the auxiliaries + commitment
    (comm, root)
}

/// API for Remainder's Ligero eval proof generation. Note that the entire
/// Ligero eval proof is now written to the `TranscriptWriter` being passed
/// in!
///
/// ## Arguments
///
/// * `input_layer_bookkeeping_table` - The bookkeeping table for the combined
///     input MLE.
/// * `challenge_coord` - The challenge at which to open the input MLE.
/// * `transcript` - The FS transcript so far
/// * `aux` - Auxiliary Ligero commit info; should be generated by the `commit` fn
/// * `comm` - Ligero commitment (coeff matrix + aux); should be generated by the `commit` fn
pub fn remainder_ligero_eval_prove<F: Field>(
    input_layer_bookkeeping_table: &[F],
    challenge_coord: &[F],
    transcript_writer: &mut impl ProverTranscript<F>,
    aux: &LigeroAuxInfo<F>,
    comm: &LigeroCommit<PoseidonSpongeHasher<F>, F>,
) -> Result<(), ProverError<&'static str>> {
    // Sanitycheck
    assert!(input_layer_bookkeeping_table.len().is_power_of_two());

    // Compute "a" and "b" from `challenge_coord`
    let (_, outer_tensor) =
        get_ml_inner_outer_tensors(challenge_coord, aux.num_rows, aux.orig_num_cols);

    // Compute evaluation proof and write to `transcript_writer`
    prove(comm, &outer_tensor[..], aux, transcript_writer)
}

/// API for Remainder's Ligero eval proof verification.
///
/// ## Arguments
/// * `proof` - Ligero evaluation proof, including the commitment.
/// * `aux` - Auxiliary information for the Ligero proof.
/// * `tr` - Fiat-Shamir transcript for verifier to sample from.
/// * `challenge_coord` - Point at which the verifier wishes to evaluate the
///     MLE.
/// * `claimed_value` - Prover claimed value for the evaluation of the MLE at
///     `challenge_coord`.
pub fn remainder_ligero_verify<F: Field>(
    commit_root: &F,
    aux: &LigeroAuxInfo<F>,
    tr: &mut impl VerifierTranscript<F>,
    challenge_coord: &[F],
    claimed_value: F,
) {
    // Sanitycheck
    assert_eq!(aux.num_rows * aux.orig_num_cols, 1 << challenge_coord.len());

    // Grab the inner/outer tensors from the challenge point
    let (inner_tensor, outer_tensor) =
        get_ml_inner_outer_tensors(challenge_coord, aux.num_rows, aux.orig_num_cols);

    let result = verify(commit_root, &outer_tensor[..], &inner_tensor[..], aux, tr).unwrap();

    assert_eq!(result, claimed_value);
}

#[cfg(test)]
mod tests {
    use crate::ligero_ml_helper::naive_eval_mle_at_challenge_point;
    use crate::ligero_structs::LigeroAuxInfo;
    use crate::utils::get_random_coeffs_for_multilinear_poly;
    use ark_std::test_rng;
    use itertools::Itertools;
    use rand::Rng;
    use remainder_shared_types::transcript::poseidon_transcript::PoseidonSponge;
    use remainder_shared_types::transcript::{
        ProverTranscript, TranscriptReader, TranscriptWriter, VerifierTranscript,
    };
    use remainder_shared_types::Fr;
    use std::iter::repeat_with;

    use super::{remainder_ligero_commit, remainder_ligero_eval_prove, remainder_ligero_verify};

    /// This tests what the Remainder interface should be doing, i.e. using the
    /// [remainder_ligero_commit()], [remainder_ligero_eval_prove()], and
    /// [remainder_ligero_verify()] functions.
    ///
    /// In particular, we
    /// * Generate a random MLE and random challenge point,
    /// * Evaluate the MLE at the challenge point,
    /// * Generate a commitment and proof, and
    /// * Verify that proof using the Remainder API for verification.
    #[test]
    fn test_remainder_flow() {
        // Setup stuff
        let ml_num_vars = 8;
        let rho_inv = 4;
        let ratio = 1_f64;
        let mut rng = test_rng();

        // Generate random polynomial
        let ml_coeffs = get_random_coeffs_for_multilinear_poly(ml_num_vars, &mut rng);
        let mut rng = test_rng();

        // Grab challenge point and claimed value
        let challenge_coord: Vec<Fr> = repeat_with(|| Fr::from(rng.gen::<u64>()))
            .take(ml_num_vars)
            .collect_vec();
        let claimed_value = naive_eval_mle_at_challenge_point(&ml_coeffs, &challenge_coord);
        let mut transcript_writer =
            TranscriptWriter::<Fr, PoseidonSponge<Fr>>::new("Test transcript");

        // Commit
        let aux = LigeroAuxInfo::new(ml_coeffs.len().next_power_of_two(), rho_inv, ratio, None);
        let (comm, root) = remainder_ligero_commit(&ml_coeffs, &aux);

        // Add commitment to transcript
        transcript_writer.append("root", root.root);

        let _prove_result = remainder_ligero_eval_prove(
            &ml_coeffs,
            &challenge_coord,
            &mut transcript_writer,
            &aux,
            &comm,
        );

        let transcript = transcript_writer.get_transcript();

        // Grab new Poseidon transcript + verify
        let mut transcript_reader = TranscriptReader::<Fr, PoseidonSponge<Fr>>::new(transcript);
        let transcript_commit_result = transcript_reader.consume_element("root").unwrap();

        remainder_ligero_verify::<Fr>(
            &transcript_commit_result,
            &aux,
            &mut transcript_reader,
            &challenge_coord,
            claimed_value,
        );
    }
}
