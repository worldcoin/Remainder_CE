use crate::adapter::{convert_lcpc_to_halo, LigeroClaim, LigeroProof};
use crate::ligero_ml_helper::{get_ml_inner_outer_tensors, naive_eval_mle_at_challenge_point};
use crate::ligero_structs::{LigeroCommit, LigeroEncoding, LigeroEvalProof};
use crate::utils::get_ligero_matrix_dims;
use crate::{verify, LcProofAuxiliaryInfo, LcRoot};
use ark_std::log2;
use remainder_shared_types::transcript::{TranscriptReader, TranscriptWriter};
use remainder_shared_types::{transcript::TranscriptSponge, FieldExt};
use tracing::instrument;

use super::poseidon_ligero::PoseidonSpongeHasher;
use super::{commit, prove};

/// Computes a Ligero commitment over a specified MLE, using Poseidon as the
/// hash function of choice for hashing both the matrix columns and the Merkle
/// root.
///
/// TODO!(ryancao): Better error-handling
///
/// ## Arguments
///
/// * `coeffs` - Vector of coefficients from the original MLE. Length must be a power of 2!
/// * `log_num_rows` - Log base 2 of the number of Ligero matrix rows.
/// * `log_orig_num_cols` - Log base 2 of the number of Ligero matrix columns. Note that
///     this plus `log_num_rows` must be equivalent to `log2(coeffs.len())`
/// * `rho_inv` - Inverse of the code rate `rho`
///
/// ## Returns
/// * `ligero_encoding` - Not useful; can be reconstructed from the eval proof
/// * `ligero_commit` - Commitment including encoded matrix
/// * `ligero_root` - Merkle tree root
/// * `aux` - Auxiliary info for Ligero
///
/// ## Examples
/// ```
/// // TODO!(ryancao) -- see tests below!
/// ```
#[instrument(skip_all, level = "debug")]
pub fn poseidon_ml_commit_prove<F: FieldExt>(
    coeffs: &Vec<F>,
    log_num_rows: usize,
    log_orig_num_cols: usize,
    rho_inv: u8,
) -> (
    LigeroEncoding<F>,
    crate::LcCommit<PoseidonSpongeHasher<F>, LigeroEncoding<F>, F>,
    LcRoot<LigeroEncoding<F>, F>,
    LcProofAuxiliaryInfo,
) {
    // --- Auxiliaries ---
    let num_rows = 1 << log_num_rows;
    let orig_num_cols = 1 << log_orig_num_cols;
    let encoded_num_cols = orig_num_cols * (rho_inv as usize);

    // --- Sanitycheck ---
    assert!(coeffs.len().is_power_of_two());
    assert_eq!(coeffs.len(), num_rows * orig_num_cols);

    // --- Create commitment ---
    let enc = LigeroEncoding::<F>::new_from_dims(orig_num_cols, encoded_num_cols);
    let comm = commit::<PoseidonSpongeHasher<F>, LigeroEncoding<F>, F>(coeffs, &enc).unwrap();

    // --- Only component of commitment which needs to be sent to the verifier is the commitment root ---
    let root: LcRoot<LigeroEncoding<F>, F> = comm.get_root();

    let aux = LcProofAuxiliaryInfo {
        rho_inv,
        encoded_num_cols,
        orig_num_cols,
        num_rows,
    };

    // --- Return the auxiliaries + commitment ---
    (enc, comm, root, aux)
}

/// Computes a Ligero proof over an MLE + evaluation point.
///
/// ## Arguments
///
/// * `coeffs` - Vector of coefficients from the original MLE. Length must be a power of 2!
/// * `rho_inv` - Inverse of the code rate `rho`
/// * `log_num_rows` - Log base 2 of the number of Ligero matrix rows.
/// * `log_orig_num_cols` - Log base 2 of the number of Ligero matrix columns. Note that
///     this plus `log_num_rows` must be equivalent to `log2(coeffs.len())`
/// * `challenge_coord` - Vector of challenge values, i.e. the evaluation point.
/// * `transcript` - The Poseidon Transcript to be used for Fiat-Shamir.
/// * `comm` - The actual Ligero commitment, as generated by `poseidon_ml_commit_prove`
/// * `root` - The Ligero root, as generated by `poseidon_ml_commit_prove`
///
/// ## Returns
/// * `eval` - the prover-claimed evaluation of the MLE at `challenge_coord`
/// * `proof` - the Ligero evaluation proof
///
/// /// ## Examples
/// ```
/// // TODO!(ryancao) -- see tests below!
/// ```
pub fn poseidon_ml_eval_prove<F: FieldExt, T: TranscriptSponge<F>>(
    coeffs: &Vec<F>,
    rho_inv: u8,
    log_num_rows: usize,
    log_orig_num_cols: usize,
    challenge_coord: &Vec<F>,
    transcript: &mut TranscriptWriter<F, T>,
    comm: LigeroCommit<PoseidonSpongeHasher<F>, F>,
    root: LcRoot<LigeroEncoding<F>, F>,
) -> (
    F,
    LigeroEvalProof<PoseidonSpongeHasher<F>, LigeroEncoding<F>, F>,
) {
    // --- Auxiliaries ---
    let rho = 1. / (rho_inv as f64);
    let num_rows = 1 << log_num_rows;
    let orig_num_cols = 1 << log_orig_num_cols;

    // --- Sanitycheck ---
    assert_eq!(coeffs.len(), num_rows * orig_num_cols);

    // --- Compute "a" and "b" from `challenge_coord` ---
    let (_, outer_tensor) = get_ml_inner_outer_tensors(challenge_coord, num_rows, orig_num_cols);

    // TODO!(ryancao): Does sending the root to the verifier happen earlier?
    transcript.append("polycommit", root.root);

    let ratio = orig_num_cols as f64 / num_rows as f64;
    let enc = LigeroEncoding::<F>::new(coeffs.len(), rho_inv, ratio);
    let maybe_ligero_eval_proof: Result<
        LigeroEvalProof<PoseidonSpongeHasher<F>, LigeroEncoding<F>, F>,
        _,
    > = prove(&comm, &outer_tensor[..], &enc, transcript);

    let ligero_eval_proof = maybe_ligero_eval_proof.unwrap();

    // --- Return the evaluation point value ---
    let eval = naive_eval_mle_at_challenge_point(&comm.coeffs, challenge_coord);

    let _claim = LigeroClaim {
        point: challenge_coord.clone(),
        eval,
    };
    (eval, ligero_eval_proof)
}

/// API for Remainder's Ligero commitment. Note that this function automatically
/// picks the Ligero matrix size!
///
/// ## Arguments
///
/// * `input_mle_bookkeeping_table` - bookkeeping table for the combined input MLE
/// * `rho_inv` - The Ligero code rate
/// * `ratio` - The Ligero unencoded matrix ratio
///
/// ## Returns
///
/// * `ligero_encoding` - Not useful; can be reconstructed from the eval proof
/// * `ligero_commit` - Commitment including encoded matrix
/// * `ligero_root` - Merkle tree root
/// * `aux` - Auxiliary info for Ligero
///
/// ## Examples
/// ```
/// // TODO!(ryancao) -- see tests below!
/// ```
#[instrument(skip_all, level = "debug")]
pub fn remainder_ligero_commit<F: FieldExt>(
    input_mle_bookkeeping_table: &Vec<F>,
    rho_inv: u8,
    ratio: f64,
) -> (
    LigeroEncoding<F>,
    crate::LcCommit<PoseidonSpongeHasher<F>, LigeroEncoding<F>, F>,
    LcRoot<LigeroEncoding<F>, F>,
    LcProofAuxiliaryInfo,
) {
    // --- Sanitycheck ---
    assert!(input_mle_bookkeeping_table.len().is_power_of_two());

    // --- Get Ligero matrix dims + sanitycheck ---
    let (num_rows, orig_num_cols, _) =
        get_ligero_matrix_dims(input_mle_bookkeeping_table.len(), rho_inv, ratio).unwrap();

    poseidon_ml_commit_prove(
        input_mle_bookkeeping_table,
        log2(num_rows) as usize,
        log2(orig_num_cols) as usize,
        rho_inv,
    )
}

/// API for Remainder's Ligero eval proof generation.
///
/// ## Arguments
///
/// * `input_layer_bookkeeping_table` - The bookkeeping table for the combined
///     input MLE.
/// * `challenge_coord` - The challenge at which to open the input MLE.
/// * `transcript` - The FS transcript so far
/// * `aux` - Auxiliary Ligero commit info; should be generated by the `commit` fn
/// * `comm` - Ligero commitment (coeff matrix + aux); should be generated by the `commit` fn
/// * `root` - Actual Merkle root commitment; should be generated by the `commit` fn
///
/// ## Returns
/// * `h2_ligero_proof` - Halo2-compatible Ligero proof for the evaluation of the original
///     polynomial (as given in `comm`) at `challenge_coord`
///
/// ## Examples
/// ```
/// // TODO!(ryancao) -- see tests below!
/// ```
pub fn remainder_ligero_eval_prove<F: FieldExt, T: TranscriptSponge<F>>(
    input_layer_bookkeeping_table: &Vec<F>,
    challenge_coord: &Vec<F>,
    transcript: &mut TranscriptWriter<F, T>,
    aux: LcProofAuxiliaryInfo,
    comm: LigeroCommit<PoseidonSpongeHasher<F>, F>,
    root: LcRoot<LigeroEncoding<F>, F>,
) -> LigeroProof<F> {
    // --- Sanitycheck ---
    assert!(input_layer_bookkeeping_table.len().is_power_of_two());

    // --- Extract data from aux ---
    let rho_inv = aux.rho_inv;
    let log_num_rows = log2(aux.num_rows) as usize;
    let log_orig_num_cols = log2(aux.orig_num_cols) as usize;

    let (_, proof) = poseidon_ml_eval_prove(
        input_layer_bookkeeping_table,
        rho_inv,
        log_num_rows,
        log_orig_num_cols,
        challenge_coord,
        transcript,
        comm,
        root.clone(),
    );

    convert_lcpc_to_halo(root, proof)
}

/// API for Remainder's Ligero eval proof verification.
///
/// ## Arguments
/// * `proof` - Ligero evaluation proof, including the commitment.
/// * `aux` - Auxiliary information for the Ligero proof.
/// * `tr` - Fiat-Shamir transcript for verifier to sample from.
/// * `challenge_coord` - Point at which the verifier wishes to evaluate the
///     MLE.
/// * `claimed_value` - Prover claimed value for the evaluation of the MLE at
///     `challenge_coord`.
///
/// ## Examples
/// ```
/// // TODO!(ryancao) -- see tests below!
/// ```
pub fn remainder_ligero_verify<F: FieldExt, T: TranscriptSponge<F>>(
    proof: &LigeroEvalProof<PoseidonSpongeHasher<F>, LigeroEncoding<F>, F>,
    aux: LcProofAuxiliaryInfo,
    tr: &mut TranscriptReader<F, T>,
    challenge_coord: &Vec<F>,
    claimed_value: F,
) {
    // --- Sanitycheck ---
    assert_eq!(aux.num_rows * aux.orig_num_cols, 1 << challenge_coord.len());

    // --- Grab the inner/outer tensors from the challenge point ---
    let (inner_tensor, outer_tensor) =
        get_ml_inner_outer_tensors(challenge_coord, aux.num_rows, aux.orig_num_cols);

    // --- Consume the root from the trascript ---
    let root = tr.consume_element("root").unwrap();

    // --- Reconstruct the encoding (TODO!(ryancao): Deprecate the encoding!) and verify ---
    let enc =
        LigeroEncoding::<F>::new_from_dims(proof.get_orig_num_cols(), proof.get_encoded_num_cols());
    let result = verify(&root, &outer_tensor[..], &inner_tensor[..], proof, &enc, tr).unwrap();

    assert_eq!(result, claimed_value);
}

#[cfg(test)]
pub mod tests {
    use crate::utils::get_random_coeffs_for_multilinear_poly;
    use crate::{
        adapter::convert_halo_to_lcpc,
        ligero_commit::{poseidon_ml_commit_prove, poseidon_ml_eval_prove},
        ligero_ml_helper::{get_ml_inner_outer_tensors, naive_eval_mle_at_challenge_point},
        verify,
    };
    use ark_std::test_rng;
    use itertools::Itertools;
    use rand::Rng;
    use remainder_shared_types::transcript::poseidon_transcript::PoseidonSponge;
    use remainder_shared_types::transcript::{TranscriptReader, TranscriptWriter};
    use remainder_shared_types::Fr;
    use std::iter::repeat_with;

    use super::{remainder_ligero_commit, remainder_ligero_eval_prove, remainder_ligero_verify};

    /// This tests what the Remainder interface should be doing, i.e. using the
    /// [remainder_ligero_commit()], [remainder_ligero_eval_prove()], and
    /// [remainder_ligero_verify()] functions.
    ///
    /// In particular, we
    /// * Generate a random MLE and random challenge point,
    /// * Evaluate the MLE at the challenge point,
    /// * Generate a commitment and proof, and
    /// * Verify that proof using the Remainder API for verification.
    #[test]
    fn test_remainder_flow() {
        // --- Setup stuff ---
        let ml_num_vars = 8;
        let rho_inv = 4;
        let ratio = 1_f64;
        let mut rng = test_rng();

        // --- Generate random polynomial ---
        let ml_coeffs = get_random_coeffs_for_multilinear_poly(ml_num_vars, &mut rng);
        let mut rng = test_rng();

        // --- Grab challenge point and claimed value ---
        let challenge_coord: Vec<Fr> = repeat_with(|| Fr::from(rng.gen::<u64>()))
            .take(ml_num_vars)
            .collect_vec();
        let claimed_value = naive_eval_mle_at_challenge_point(&ml_coeffs, &challenge_coord);
        let mut transcript_writer =
            TranscriptWriter::<Fr, PoseidonSponge<Fr>>::new("Test transcript");

        // --- Commit, prove, convert ---
        let (_, comm, root, aux) = remainder_ligero_commit(&ml_coeffs, rho_inv, ratio);
        let h2_ligero_proof: crate::adapter::LigeroProof<Fr> = remainder_ligero_eval_prove(
            &ml_coeffs,
            &challenge_coord,
            &mut transcript_writer,
            aux.clone(),
            comm,
            root.clone(),
        );
        let (_, ligero_eval_proof, _) = convert_halo_to_lcpc(aux.clone(), h2_ligero_proof);

        let transcript = transcript_writer.get_transcript();

        // --- Grab new Poseidon transcript + verify ---
        let mut transcript_reader = TranscriptReader::<Fr, PoseidonSponge<Fr>>::new(transcript);
        remainder_ligero_verify::<Fr, PoseidonSponge<Fr>>(
            &ligero_eval_proof,
            aux,
            &mut transcript_reader,
            &challenge_coord,
            claimed_value,
        );
    }

    /// This tests the "raw" [poseidon_ml_commit_prove()] and [verify()] functions.
    ///
    /// In particular, we
    /// * Generate a random MLE and random challenge point to evaluate the MLE at.
    /// * Code a fixed set of hyperparameters to test the commitment + eval
    ///     proof and verify functions with.
    /// * Call the corresponding [poseidon_ml_commit_prove()] and [verify()]
    ///     functions, and ensure that the proof verifies.
    #[test]
    fn test_commit_eval_proof() {
        // --- Ligero hyperparams ---
        let ml_num_vars = 8;
        let log_num_rows = 4;
        let log_orig_num_cols = 4;
        let rho_inv = 4;
        let _ratio = 1_f64;

        let mut rng = test_rng();
        let num_rows = 1 << log_num_rows;
        let orig_num_cols = 1 << log_orig_num_cols;

        // --- Generate random coeffs and random challenge point to evaluate at ---
        let mut rng = test_rng();
        let ml_coeffs = get_random_coeffs_for_multilinear_poly(ml_num_vars, &mut rng);
        let challenge_coord: Vec<Fr> = repeat_with(|| Fr::from(rng.gen::<u64>()))
            .take(ml_num_vars)
            .collect_vec();
        let correct_eval = naive_eval_mle_at_challenge_point(&ml_coeffs, &challenge_coord);

        // --- Commit phase ---
        let (enc, comm, root, _) =
            poseidon_ml_commit_prove::<Fr>(&ml_coeffs, log_num_rows, log_orig_num_cols, rho_inv);

        // --- Eval phase ---
        let mut poseidon_writer =
            TranscriptWriter::<Fr, PoseidonSponge<Fr>>::new("Test transcript");
        let (_eval, proof) = poseidon_ml_eval_prove(
            &ml_coeffs,
            rho_inv,
            log_num_rows,
            log_orig_num_cols,
            &challenge_coord,
            &mut poseidon_writer,
            comm,
            root.clone(),
        );

        // --- Verify phase ---
        let transcript = poseidon_writer.get_transcript();
        let mut poseidon_reader = TranscriptReader::<Fr, PoseidonSponge<Fr>>::new(transcript);
        let prover_root = poseidon_reader.consume_element("root").unwrap();
        assert_eq!(prover_root, root.root);
        let (inner_tensor, outer_tensor) =
            get_ml_inner_outer_tensors(&challenge_coord, num_rows, orig_num_cols);
        let result = verify(
            &root.root,
            &outer_tensor,
            &inner_tensor,
            &proof,
            &enc,
            &mut poseidon_reader,
        )
        .unwrap();

        assert_eq!(result, correct_eval);
    }
}
