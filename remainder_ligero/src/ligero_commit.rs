use crate::ligero_ml_helper::get_ml_inner_outer_tensors;
use crate::ligero_structs::{LigeroAuxInfo, LigeroCommit, LigeroRoot};
use crate::FieldExt;
use crate::{verify, ProverError};
use remainder_shared_types::transcript::{ProverTranscript, TranscriptSponge};
use remainder_shared_types::transcript::{TranscriptReader, VerifierTranscript};
use tracing::instrument;

use super::poseidon_ligero::PoseidonSpongeHasher;
use super::{commit, prove};

/// API for Remainder's Ligero commitment. Note that this function automatically
/// picks the Ligero matrix size, and that [PoseidonSpongeHasher] is automatically used as
/// the hasher of choice.
///
/// ## Arguments
///
/// * `input_mle_bookkeeping_table` - bookkeeping table for the combined input MLE
/// * `rho_inv` - The Ligero code rate
/// * `ratio` - The Ligero unencoded matrix ratio
///
/// ## Returns
///
/// * `ligero_encoding` - Not useful; can be reconstructed from the eval proof
/// * `ligero_commit` - Commitment including encoded matrix
/// * `ligero_root` - Merkle tree root
/// * `aux` - Auxiliary info for Ligero
///
/// ## Examples
/// ```
/// // TODO!(ryancao) -- see tests below!
/// ```
#[instrument(skip_all, level = "debug")]
pub fn remainder_ligero_commit<F: FieldExt>(
    input_mle_bookkeeping_table: &[F],
    rho_inv: u8,
    ratio: f64,
    maybe_num_cols_open: Option<usize>,
) -> (
    LigeroAuxInfo<F>,
    LigeroCommit<PoseidonSpongeHasher<F>, F>,
    LigeroRoot<F>,
) {
    // --- Sanitycheck ---
    assert!(input_mle_bookkeeping_table.len().is_power_of_two());

    // --- Create metadata struct ---
    let aux = LigeroAuxInfo::<F>::new(
        input_mle_bookkeeping_table.len(),
        rho_inv,
        ratio,
        maybe_num_cols_open,
    );

    // --- Create commitment ---
    let comm =
        commit::<PoseidonSpongeHasher<F>, LigeroAuxInfo<F>, F>(input_mle_bookkeeping_table, &aux)
            .unwrap();

    // --- Only component of commitment which needs to be sent to the verifier is the commitment root ---
    let root: LigeroRoot<F> = comm.get_root();

    // --- Return the auxiliaries + commitment ---
    (aux, comm, root)
}

/// API for Remainder's Ligero eval proof generation. Note that the entire
/// Ligero eval proof is now written to the `TranscriptWriter` being passed
/// in!
///
/// ## Arguments
///
/// * `input_layer_bookkeeping_table` - The bookkeeping table for the combined
///     input MLE.
/// * `challenge_coord` - The challenge at which to open the input MLE.
/// * `transcript` - The FS transcript so far
/// * `aux` - Auxiliary Ligero commit info; should be generated by the `commit` fn
/// * `comm` - Ligero commitment (coeff matrix + aux); should be generated by the `commit` fn
///
/// ## Examples
/// ```
/// // TODO!(ryancao) -- see tests below!
/// ```
pub fn remainder_ligero_eval_prove<F: FieldExt>(
    input_layer_bookkeeping_table: &[F],
    challenge_coord: &[F],
    transcript_writer: &mut impl ProverTranscript<F>,
    aux: &LigeroAuxInfo<F>,
    comm: LigeroCommit<PoseidonSpongeHasher<F>, F>,
) -> Result<(), ProverError<&'static str>> {
    // --- Sanitycheck ---
    assert!(input_layer_bookkeeping_table.len().is_power_of_two());

    // --- Compute "a" and "b" from `challenge_coord` ---
    let (_, outer_tensor) =
        get_ml_inner_outer_tensors(challenge_coord, aux.num_rows, aux.orig_num_cols);

    // --- Compute evaluation proof and write to `transcript_writer`
    prove(&comm, &outer_tensor[..], &aux, transcript_writer)
}

/// API for Remainder's Ligero eval proof verification.
///
/// ## Arguments
/// * `proof` - Ligero evaluation proof, including the commitment.
/// * `aux` - Auxiliary information for the Ligero proof.
/// * `tr` - Fiat-Shamir transcript for verifier to sample from.
/// * `challenge_coord` - Point at which the verifier wishes to evaluate the
///     MLE.
/// * `claimed_value` - Prover claimed value for the evaluation of the MLE at
///     `challenge_coord`.
///
/// ## Examples
/// ```
/// // TODO!(ryancao) -- see tests below!
/// ```
pub fn remainder_ligero_verify<F: FieldExt>(
    commit_root: F,
    aux: &LigeroAuxInfo<F>,
    tr: &mut impl VerifierTranscript<F>,
    challenge_coord: &[F],
    claimed_value: F,
) {
    // --- Sanitycheck ---
    assert_eq!(aux.num_rows * aux.orig_num_cols, 1 << challenge_coord.len());

    // --- Grab the inner/outer tensors from the challenge point ---
    let (inner_tensor, outer_tensor) =
        get_ml_inner_outer_tensors(challenge_coord, aux.num_rows, aux.orig_num_cols);

    let result = verify(&commit_root, &outer_tensor[..], &inner_tensor[..], aux, tr).unwrap();

    assert_eq!(result, claimed_value);
}

#[cfg(test)]
pub mod tests {
    use crate::utils::get_random_coeffs_for_multilinear_poly;
    use crate::{
        ligero_ml_helper::{get_ml_inner_outer_tensors, naive_eval_mle_at_challenge_point},
        verify,
    };
    use ark_std::test_rng;
    use itertools::Itertools;
    use rand::Rng;
    use remainder_shared_types::transcript::poseidon_transcript::PoseidonSponge;
    use remainder_shared_types::transcript::{
        ProverTranscript, TranscriptReader, TranscriptWriter, VerifierTranscript,
    };
    use remainder_shared_types::Fr;
    use std::iter::repeat_with;

    use super::{remainder_ligero_commit, remainder_ligero_eval_prove, remainder_ligero_verify};

    /// This tests what the Remainder interface should be doing, i.e. using the
    /// [remainder_ligero_commit()], [remainder_ligero_eval_prove()], and
    /// [remainder_ligero_verify()] functions.
    ///
    /// In particular, we
    /// * Generate a random MLE and random challenge point,
    /// * Evaluate the MLE at the challenge point,
    /// * Generate a commitment and proof, and
    /// * Verify that proof using the Remainder API for verification.
    #[test]
    fn test_remainder_flow() {
        // --- Setup stuff ---
        let ml_num_vars = 8;
        let rho_inv = 4;
        let ratio = 1_f64;
        let mut rng = test_rng();

        // --- Generate random polynomial ---
        let ml_coeffs = get_random_coeffs_for_multilinear_poly(ml_num_vars, &mut rng);
        let mut rng = test_rng();

        // --- Grab challenge point and claimed value ---
        let challenge_coord: Vec<Fr> = repeat_with(|| Fr::from(rng.gen::<u64>()))
            .take(ml_num_vars)
            .collect_vec();
        let claimed_value = naive_eval_mle_at_challenge_point(&ml_coeffs, &challenge_coord);
        let mut transcript_writer =
            TranscriptWriter::<Fr, PoseidonSponge<Fr>>::new("Test transcript");

        // --- Commit ---
        let (aux, comm, root) = remainder_ligero_commit(&ml_coeffs, rho_inv, ratio, None);

        // --- Add commitment to transcript ---
        transcript_writer.append("root", root.root);

        let _prove_result = remainder_ligero_eval_prove(
            &ml_coeffs,
            &challenge_coord,
            &mut transcript_writer,
            &aux,
            comm,
        );

        let transcript = transcript_writer.get_transcript();

        // --- Grab new Poseidon transcript + verify ---
        let mut transcript_reader = TranscriptReader::<Fr, PoseidonSponge<Fr>>::new(transcript);
        let transcript_commit_result = transcript_reader.consume_element("root").unwrap();

        remainder_ligero_verify::<Fr>(
            transcript_commit_result,
            &aux,
            &mut transcript_reader,
            &challenge_coord,
            claimed_value,
        );
    }

    // /// This tests the "raw" [poseidon_ml_commit_prove()] and [verify()] functions.
    // ///
    // /// In particular, we
    // /// * Generate a random MLE and random challenge point to evaluate the MLE at.
    // /// * Code a fixed set of hyperparameters to test the commitment + eval
    // ///     proof and verify functions with.
    // /// * Call the corresponding [poseidon_ml_commit_prove()] and [verify()]
    // ///     functions, and ensure that the proof verifies.
    // #[test]
    // fn test_commit_eval_proof() {
    //     // --- Ligero hyperparams ---
    //     let ml_num_vars = 8;
    //     let log_num_rows = 4;
    //     let log_orig_num_cols = 4;
    //     let rho_inv = 4;
    //     let _ratio = 1_f64;

    //     let num_rows = 1 << log_num_rows;
    //     let orig_num_cols = 1 << log_orig_num_cols;

    //     // --- Generate random coeffs and random challenge point to evaluate at ---
    //     let mut rng = test_rng();
    //     let ml_coeffs = get_random_coeffs_for_multilinear_poly(ml_num_vars, &mut rng);
    //     let challenge_coord: Vec<Fr> = repeat_with(|| Fr::from(rng.gen::<u64>()))
    //         .take(ml_num_vars)
    //         .collect_vec();
    //     let correct_eval = naive_eval_mle_at_challenge_point(&ml_coeffs, &challenge_coord);

    //     // --- Commit phase ---
    //     let (enc, comm, root, aux) =
    //         poseidon_ml_commit_prove::<Fr>(&ml_coeffs, log_num_rows, log_orig_num_cols, rho_inv);

    //     // --- Eval phase ---
    //     let mut poseidon_writer =
    //         TranscriptWriter::<Fr, PoseidonSponge<Fr>>::new("Test transcript");
    //     poseidon_ml_eval_prove(
    //         &ml_coeffs,
    //         rho_inv,
    //         log_num_rows,
    //         log_orig_num_cols,
    //         &challenge_coord,
    //         &mut poseidon_writer,
    //         comm,
    //         root.clone(),
    //     );

    //     // --- Verify phase ---
    //     let transcript = poseidon_writer.get_transcript();
    //     let mut poseidon_reader = TranscriptReader::<Fr, PoseidonSponge<Fr>>::new(transcript);
    //     let prover_root = poseidon_reader.consume_element("root").unwrap();
    //     assert_eq!(prover_root, root.root);
    //     let (inner_tensor, outer_tensor) =
    //         get_ml_inner_outer_tensors(&challenge_coord, num_rows, orig_num_cols);
    //     let result = verify(
    //         &root.root,
    //         &outer_tensor,
    //         &inner_tensor,
    //         &enc,
    //         &mut poseidon_reader,
    //     )
    //     .unwrap();

    //     assert_eq!(result, correct_eval);
    // }
}
