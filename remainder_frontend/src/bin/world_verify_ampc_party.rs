use std::{
    fs::File,
    io::Write,
    path::{Path, PathBuf},
};

use clap::{command, Parser};
use itertools::Itertools;
use remainder::mle::evals::MultilinearExtension;
use remainder_frontend::{
    hyrax_worldcoin_mpc::mpc_prover::{
        print_features_status, MPCPartyProof, V3MPCCircuitAndAuxMles, V3MPCCommitments,
    },
    worldcoin_mpc::{
        circuits::{
            MPC_ENCODING_MATRIX_SHRED, MPC_EVALUATION_POINTS_SHRED, MPC_IRISCODE_INPUT_LAYER,
            MPC_LOOKUP_TABLE_VALUES_SHRED, MPC_MASKCODE_INPUT_LAYER, MPC_SHARES_LAYER,
            MPC_SHARES_SHRED, MPC_SLOPES_LAYER,
        },
        parameters::GR4_MODULUS,
    },
    zk_iriscode_ss::{
        self,
        io::read_bytes_from_file,
        parameters::{IRISCODE_LEN, SHAMIR_SECRET_SHARE_SLOPE_LOG_NUM_COLS},
    },
};
use remainder_hyrax::utils::convert_fr_into_u16;
use remainder_shared_types::{perform_function_under_expected_configs, Bn256Point, Fr};

#[cfg(feature = "print-trace")]
use tracing::Level;
#[cfg(feature = "print-trace")]
use tracing_subscriber::fmt;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct CliArguments {
    /// Path to the circuit description generated by the
    /// `world_gen_iriscode_secret_share_circuit_descriptions` binary.
    #[arg(long)]
    circuit: PathBuf,

    /// Path to the `hashes.json` file containing the commitment hashes.
    #[arg(long)]
    hashes: PathBuf,

    /// Path to the secret share generation proof file. Note that by default
    /// the filename is "world_mpc_party_{party_idx}.zkp".
    #[arg(long)]
    secret_share_proof: PathBuf,

    /// Path to the commitments file. Note that by default the filename is
    /// "commitments.zkp".
    #[arg(long)]
    commitments: PathBuf,

    /// AMPC party index. Note that this needs to be one of [0, 1, 2].
    #[arg(long)]
    ampc_party_index: usize,

    /// Path to the directory where secret share bytes should be written to.
    /// Note that by default the filename is
    /// "secret_shares_party_{idx}_{left/right}_masked_iriscode.bin".
    #[arg(long)]
    secret_share_bytes_dir: PathBuf,
}

fn main() {
    #[cfg(feature = "print-trace")]
    let _subscriber = fmt().with_max_level(Level::DEBUG).init();

    // Sanitycheck by logging the current settings.
    perform_function_under_expected_configs!(
        print_features_status,
        &zk_iriscode_ss::EXPECTED_PROVER_CONFIG,
        &zk_iriscode_ss::EXPECTED_VERIFIER_CONFIG,
    );

    // Parse arguments and verify secret share generation proofs.
    let cli = CliArguments::parse();
    perform_function_under_expected_configs!(
        verify_secret_share_proofs,
        &zk_iriscode_ss::EXPECTED_PROVER_CONFIG,
        &zk_iriscode_ss::EXPECTED_VERIFIER_CONFIG,
        &cli.circuit,
        &cli.hashes,
        &cli.secret_share_proof,
        &cli.commitments,
        cli.ampc_party_index,
        &cli.secret_share_bytes_dir
    );
}

/// Checks that the secret shares for the {left, right} masked iris codes
/// given to the AMPC party with index `ampc_party_index` are correct with
/// respect to the iris and mask code Hyrax commitments, as well as the slope
/// Hyrax commitments, within the auxiliary commitments file.
///
/// In particular, it checks that the following processes were run correctly:
/// * {left mask code, left iris code, party `ampc_party_index`} --> left secret share `ampc_party_index`
/// * {right mask code, right iris code, party `ampc_party_index`} --> right secret share `ampc_party_index`
fn verify_secret_share_proofs(
    path_to_circuit_description: &Path,
    path_to_hashes_json: &Path,
    path_to_secret_share_proof: &Path,
    path_to_aux_commitments: &Path,
    ampc_party_index: usize,
    secret_share_bytes_dir: &Path,
) {
    // Check that the AMPC party index is within bounds
    assert!(ampc_party_index == 0 || ampc_party_index == 1 || ampc_party_index == 2);

    println!("Verifying...");

    let serialized_circuit_and_aux_mles =
        read_bytes_from_file(path_to_circuit_description.as_os_str().to_str().unwrap());
    let v3_mpc_circuit_and_aux_mles =
        V3MPCCircuitAndAuxMles::<Fr>::deserialize(&serialized_circuit_and_aux_mles);

    let serialized_proof =
        read_bytes_from_file(path_to_secret_share_proof.as_os_str().to_str().unwrap());
    let mpc_party_proof = MPCPartyProof::deserialize(&serialized_proof);

    let serialized_commitments =
        read_bytes_from_file(path_to_aux_commitments.as_os_str().to_str().unwrap());

    let v3_mpc_commitments = V3MPCCommitments::<Bn256Point>::deserialize(&serialized_commitments);

    let hashes_file = File::open(path_to_hashes_json).expect("Could not open hashes.json file.");
    let _parsed_hashes: serde_json::Value =
        serde_json::from_reader(hashes_file).expect("Could not parse hashes.json.");

    let mpc_circuit_ref = &v3_mpc_circuit_and_aux_mles.mpc_circuit_and_aux_mles_all_3_parties;
    let mut circuit = mpc_circuit_ref.mpc_circuit.clone();

    circuit.set_input(
        MPC_ENCODING_MATRIX_SHRED,
        mpc_circuit_ref.encoding_matrix.clone(),
    );
    circuit.set_input(
        MPC_EVALUATION_POINTS_SHRED,
        mpc_circuit_ref.evaluation_points[ampc_party_index].clone(),
    );
    circuit.set_input(
        MPC_LOOKUP_TABLE_VALUES_SHRED,
        MultilinearExtension::new((0..GR4_MODULUS).map(Fr::from).collect()),
    );

    for is_left_eye in [false, true] {
        println!("Verifying mpc secret share circuit, is_left_eye = {is_left_eye}");

        let mut circuit = circuit.clone();

        let proof = if is_left_eye {
            mpc_party_proof.get_left_eye_proof_ref()
        } else {
            mpc_party_proof.get_right_eye_proof_ref()
        };

        let shares_layer_id = mpc_circuit_ref
            .mpc_circuit
            .get_input_layer_description_ref(MPC_SHARES_LAYER)
            .layer_id;

        let shares_mle = proof
            .public_inputs
            .iter()
            .find(|(layer_id, _)| *layer_id == shares_layer_id)
            .unwrap()
            .1
            .as_ref()
            .unwrap()
            .clone();

        circuit.set_input(MPC_SHARES_SHRED, shares_mle);

        let mut verifiable_circuit = circuit
            .gen_hyrax_verifiable_circuit()
            .expect("Failed to generate verifiable circuit");

        verifiable_circuit
            .set_commitment_parameters(MPC_SLOPES_LAYER, SHAMIR_SECRET_SHARE_SLOPE_LOG_NUM_COLS)
            .unwrap();

        verifiable_circuit
            .set_pre_commitment(
                MPC_IRISCODE_INPUT_LAYER,
                v3_mpc_commitments
                    .get_code_commit_ref(false, is_left_eye)
                    .clone(),
            )
            .expect("Failed to set pre-commitment for the MPC Iriscode Input Layer");

        verifiable_circuit
            .set_pre_commitment(
                MPC_MASKCODE_INPUT_LAYER,
                v3_mpc_commitments
                    .get_code_commit_ref(true, is_left_eye)
                    .clone(),
            )
            .expect("Failed to set pre-commitment for the MPC Maskcode Input Layer");

        verifiable_circuit
            .set_pre_commitment(
                MPC_SLOPES_LAYER,
                v3_mpc_commitments.get_slope_commit_ref(is_left_eye).clone(),
            )
            .expect("Failed to set pre-commitment for the MPC Slopes Input Layer");

        match mpc_party_proof.verify_mpc_proof(is_left_eye, &verifiable_circuit, shares_layer_id) {
            Ok(secret_share_mle) => {
                println!("MPC Verification succeeded!!");

                // First truncate secret shares, then convert into `Vec<u16>`.
                let secret_shares = secret_share_mle
                    .iter()
                    .take(IRISCODE_LEN)
                    .map(convert_fr_into_u16)
                    .map(|maybe_x| match maybe_x {
                        Ok(x) => x,
                        Err(e) => {
                            panic!("Conversion into `u16` failed: {e:?}");
                        }
                    })
                    .collect_vec();

                // Serialize into binary...
                let serialized_secret_shares = bincode::serialize(&secret_shares).unwrap();

                // ...And write to the desired file!
                let mut f = File::create(secret_share_bytes_dir.join(format!(
                    "secret_shares_party_{}_{}_masked_iriscode.bin",
                    ampc_party_index,
                    if is_left_eye { "left" } else { "right" }
                )))
                .expect("Failed to create/open secret share bytes file.");
                f.write_all(&serialized_secret_shares)
                    .expect("Failed to write secret share bytes to file.");
            }
            Err(err) => println!("MPC Verification failed with error: {err:#?}"),
        }
    }
}
