use std::{
    fs::File,
    io::Write,
    path::{Path, PathBuf},
};

use crate::{
    hyrax_worldcoin_mpc::mpc_prover::{
        print_features_status, MPCPartyProof, V3MPCCircuitAndAuxMles, V3MPCCommitments,
    },
    tfh_circuits::tfh_config,
    zk_iriscode_ss::{io::read_bytes_from_file, parameters::IRISCODE_LEN},
};
use clap::{command, Parser};
use itertools::Itertools;
use remainder_hyrax::utils::convert_fr_into_u16;
use remainder_shared_types::{perform_function_under_expected_configs, Bn256Point, Fr};

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct CliArguments {
    /// Path to the circuit description generated by the
    /// `world_gen_iriscode_secret_share_circuit_descriptions` binary.
    #[arg(long)]
    circuit: PathBuf,

    /// Path to the `hashes.json` file containing the commitment hashes.
    #[arg(long)]
    hashes: PathBuf,

    /// Path to the secret share generation proof file. Note that by default
    /// the filename is "world_mpc_party_{party_idx}.zkp".
    #[arg(long)]
    secret_share_proof: PathBuf,

    /// Path to the commitments file. Note that by default the filename is
    /// "commitments.zkp".
    #[arg(long)]
    commitments: PathBuf,

    /// AMPC party index. Note that this needs to be one of [0, 1, 2].
    #[arg(long)]
    ampc_party_index: usize,

    /// Path to the directory where secret share bytes should be written to.
    /// Note that by default the filename is
    /// "secret_shares_party_{idx}_{left/right}_masked_iriscode.bin".
    #[arg(long)]
    secret_share_bytes_dir: PathBuf,
}

fn main() {
    // Sanitycheck by logging the current settings.
    perform_function_under_expected_configs!(
        print_features_status,
        &tfh_config::EXPECTED_PROVER_CONFIG,
        &tfh_config::EXPECTED_VERIFIER_CONFIG,
    );

    // Parse arguments and verify secret share generation proofs.
    let cli = CliArguments::parse();
    perform_function_under_expected_configs!(
        verify_secret_share_proofs,
        &tfh_config::EXPECTED_PROVER_CONFIG,
        &tfh_config::EXPECTED_VERIFIER_CONFIG,
        &cli.circuit,
        &cli.hashes,
        &cli.secret_share_proof,
        &cli.commitments,
        cli.ampc_party_index,
        &cli.secret_share_bytes_dir
    );
}

/// Checks that the secret shares for the {left, right} masked iris codes
/// given to the AMPC party with index `ampc_party_index` are correct with
/// respect to the iris and mask code Hyrax commitments, as well as the slope
/// Hyrax commitments, within the auxiliary commitments file.
///
/// In particular, it checks that the following processes were run correctly:
/// * {left mask code, left iris code, party `ampc_party_index`} --> left secret share `ampc_party_index`
/// * {right mask code, right iris code, party `ampc_party_index`} --> right secret share `ampc_party_index`
fn verify_secret_share_proofs(
    path_to_circuit_description: &Path,
    path_to_hashes_json: &Path,
    path_to_secret_share_proof: &Path,
    path_to_aux_commitments: &Path,
    ampc_party_index: usize,
    secret_share_bytes_dir: &Path,
) {
    // Check that the AMPC party index is within bounds
    assert!(ampc_party_index == 0 || ampc_party_index == 1 || ampc_party_index == 2);

    println!("Verifying...");
    // let committer = V3Prover::default_committer();

    let serialized_circuit_and_aux_mles =
        read_bytes_from_file(path_to_circuit_description.as_os_str().to_str().unwrap());
    let v3_mpc_circuit_and_aux_mles =
        V3MPCCircuitAndAuxMles::<Fr>::deserialize(&serialized_circuit_and_aux_mles);

    let serialized_proof =
        read_bytes_from_file(path_to_secret_share_proof.as_os_str().to_str().unwrap());
    let mut mpc_party_proof = MPCPartyProof::deserialize(&serialized_proof);

    let serialized_commitments =
        read_bytes_from_file(path_to_aux_commitments.as_os_str().to_str().unwrap());
    let v3_mpc_commitments: V3MPCCommitments<Bn256Point> =
        V3MPCCommitments::deserialize(&serialized_commitments);

    let hashes_file = File::open(path_to_hashes_json).expect("Could not open hashes.json file.");
    let _parsed_hashes: serde_json::Value =
        serde_json::from_reader(hashes_file).expect("Could not parse hashes.json.");

    let circuit = v3_mpc_circuit_and_aux_mles.mpc_circuit_and_aux_mles_all_3_parties
        [ampc_party_index]
        .get_circuit();

    let aux_mle = v3_mpc_circuit_and_aux_mles.mpc_circuit_and_aux_mles_all_3_parties
        [ampc_party_index]
        .get_aux_mle();

    for is_left_eye in [false, true] {
        println!("Verifying mpc secret share circuit, is_left_eye = {is_left_eye}");

        let proof = if is_left_eye {
            mpc_party_proof.get_left_eye_proof_ref()
        } else {
            mpc_party_proof.get_right_eye_proof_ref()
        };

        // check that the commitments are the same for iris code
        {
            println!("Checking that the iris code commitment with the proof matches that within the V3MPCCommitments struct...");
            let iris_code_commitment = proof
                .hyrax_input_proofs
                .iter()
                .find(|proof| proof.layer_id == circuit.iris_code_input_layer.layer_id)
                .unwrap()
                .input_commitment
                .clone();

            assert_eq!(
                &iris_code_commitment,
                v3_mpc_commitments.get_code_commit_ref(false, is_left_eye)
            );
            println!("Iris code commitment matches!");
        }

        // check that the commitments are the same for mask code
        {
            println!("Checking that the mask code commitment with the proof matches that within the V3MPCCommitments struct...");
            let mask_code_commitment = proof
                .hyrax_input_proofs
                .iter()
                .find(|proof| proof.layer_id == circuit.mask_code_input_layer.layer_id)
                .unwrap()
                .input_commitment
                .clone();

            assert_eq!(
                &mask_code_commitment,
                v3_mpc_commitments.get_code_commit_ref(true, is_left_eye)
            );
            println!("Mask code commitment matches!");
        }

        // check that the slope commitment is the same
        {
            println!("Checking that the Shamir SS polynomial's slope commitment with the proof matches that within the V3MPCCommitments struct...");
            let slope_commitment = proof
                .hyrax_input_proofs
                .iter()
                .find(|proof| proof.layer_id == circuit.slope_input_layer.layer_id)
                .unwrap()
                .input_commitment
                .clone();

            assert_eq!(
                &slope_commitment,
                v3_mpc_commitments.get_slope_commit_ref(is_left_eye)
            );
            println!("Shamir SS polynomial's slope commitment matches!");
        }

        // The verifier forcibly inserts the correct public "auxiliary" MLEs
        // (e.g. lookup table, evaluation points, encoding matrix) into the
        // proof, since these are omitted by the prover by construction.
        mpc_party_proof.insert_aux_public_data_by_id(
            is_left_eye,
            aux_mle,
            circuit.auxiliary_invariant_public_input_layer.layer_id,
        );

        match mpc_party_proof.verify_mpc_proof(is_left_eye, circuit) {
            Ok(secret_share_mle) => {
                println!("MPC Verification succeeded!!");

                // First truncate secret shares, then convert into `Vec<u16>`.
                let secret_shares = secret_share_mle
                    .iter()
                    .take(IRISCODE_LEN)
                    .map(convert_fr_into_u16)
                    .map(|maybe_x| match maybe_x {
                        Ok(x) => x,
                        Err(e) => {
                            panic!("Conversion into `u16` failed: {e:?}");
                        }
                    })
                    .collect_vec();

                // Serialize into binary...
                let serialized_secret_shares = bincode::serialize(&secret_shares).unwrap();

                // ...And write to the desired file!
                let mut f = File::create(secret_share_bytes_dir.join(format!(
                    "secret_shares_party_{}_{}_masked_iriscode.bin",
                    ampc_party_index,
                    if is_left_eye { "left" } else { "right" }
                )))
                .expect("Failed to create/open secret share bytes file.");
                f.write_all(&serialized_secret_shares)
                    .expect("Failed to write secret share bytes to file.");
            }
            Err(err) => println!("MPC Verification failed with error: {err:#?}"),
        }
    }
}
