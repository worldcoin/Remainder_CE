use std::{
    fs::File,
    path::{Path, PathBuf},
};

use clap::{command, Parser};
use remainder_frontend::{
    hyrax_worldcoin::{
        orb::IMAGE_COMMIT_LOG_NUM_COLS,
        v3::{V3CircuitAndAuxData, V3Proof},
    },
    hyrax_worldcoin_mpc::mpc_prover::{print_features_status, V3MPCCommitments},
    zk_iriscode_ss::{
        circuits::{
            iriscode_ss_attach_aux_data, iriscode_ss_attach_input_data, V3_INPUT_IMAGE_LAYER,
            V3_SIGN_BITS_LAYER,
        },
        io::read_bytes_from_file,
    },
};
use remainder_shared_types::{
    config::{GKRCircuitProverConfig, GKRCircuitVerifierConfig},
    perform_function_under_expected_configs, Bn256Point, Fr,
};

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct CliArguments {
    /// Path to the circuit description generated by the
    /// `world_gen_iriscode_secret_share_circuit_descriptions` binary.
    #[arg(long)]
    circuit: PathBuf,

    /// Path to the `hashes.json` file containing the commitment hashes.
    #[arg(long)]
    hashes: PathBuf,

    /// Path to the iriscode generation Hyrax proof file. Note that by default
    /// the filename is "world_v3.zkp".
    #[arg(long)]
    v3_proof: PathBuf,

    /// Path to the commitments file. Note that by default the filename is
    /// "commitments.zkp".
    #[arg(long)]
    commitments: PathBuf,
}

fn main() {
    // Sanitycheck by logging the current settings.
    perform_function_under_expected_configs!(
        print_features_status,
        &GKRCircuitProverConfig::hyrax_compatible_memory_optimized_default(),
        &GKRCircuitVerifierConfig::hyrax_compatible_runtime_optimized_default(),
    );

    let cli = CliArguments::parse();

    perform_function_under_expected_configs!(
        verify_v3_iriscode_proof,
        &GKRCircuitProverConfig::hyrax_compatible_memory_optimized_default(),
        &GKRCircuitVerifierConfig::hyrax_compatible_runtime_optimized_default(),
        &cli.circuit,
        &cli.hashes,
        &cli.v3_proof,
        &cli.commitments
    );
}

/// Checks that the Hyrax commitments to the {left, right} iris {mask, image}
/// are correct with respect to the Hyrax proofs of correct iriscode
/// computation. In particular, this function verifies the four Hyrax proofs
/// which prove the correctness of the following processes:
/// * {left eye, mask} --> left mask code
/// * {left eye, iris} --> left iris code
/// * {right eye, mask} --> right mask code
/// * {right eye, iris} --> right iris code
///
/// and additionally checks that the commitments to the iris/mask codes within
/// each match those given in the auxiliary commitment data.
fn verify_v3_iriscode_proof(
    path_to_circuit_description: &Path,
    path_to_hashes_json: &Path,
    path_to_v3_proof: &Path,
    path_to_aux_commitments: &Path,
) {
    println!("Verifying...");

    let serialized_circuit =
        read_bytes_from_file(path_to_circuit_description.as_os_str().to_str().unwrap());
    let v3_circuit_and_aux_data = V3CircuitAndAuxData::<Fr>::deserialize(&serialized_circuit);

    let serialized_proof = read_bytes_from_file(path_to_v3_proof.as_os_str().to_str().unwrap());
    let mut v3_proof = V3Proof::deserialize(&serialized_proof);

    let serialized_commitments =
        read_bytes_from_file(path_to_aux_commitments.as_os_str().to_str().unwrap());
    let v3_mpc_commitments: V3MPCCommitments<Bn256Point> =
        V3MPCCommitments::deserialize(&serialized_commitments);

    let hashes_file = File::open(path_to_hashes_json).expect("Could not open hashes.json file.");
    let parsed_hashes: serde_json::Value =
        serde_json::from_reader(hashes_file).expect("Could not parse hashes.json.");

    for is_mask in [false, true] {
        for is_left_eye in [false, true] {
            println!("Verifying combination (is_mask, is_left_eye) = ({is_mask}, {is_left_eye})");

            let eye = if is_left_eye { "left" } else { "right" };
            let iris_or_mask = if is_mask { "mask" } else { "image" };
            let commitment_hash_entry = format!("{eye}_normalized_{iris_or_mask}_commitment.bin");
            let commitment_hash = parsed_hashes
                .get(&commitment_hash_entry)
                .unwrap_or_else(|| {
                    panic!("Could not find entry {commitment_hash_entry} in hashes.json")
                })
                .as_str()
                .unwrap_or_else(|| panic!("Field {commitment_hash_entry} is not a string!"));

            let circuit = v3_circuit_and_aux_data.get_circuit();
            /*
            let aux_mle = if is_mask {
                v3_mpc_circuit_and_aux_mle
                    .v3_circuit_and_aux_mles
                    .get_mask_aux_mle()
            } else {
                v3_mpc_circuit_and_aux_mle
                    .v3_circuit_and_aux_mles
                    .get_iris_aux_mle()
            };
            */

            // check that the commitments are the same for iris code
            {
                let code_layer_id = v3_circuit_and_aux_data
                    .get_circuit()
                    .get_input_layer_description_ref(V3_SIGN_BITS_LAYER)
                    .layer_id;
                let code_commitment = v3_proof
                    .get(is_mask, is_left_eye)
                    .hyrax_input_proofs
                    .iter()
                    .find(|proof| proof.layer_id == code_layer_id)
                    .unwrap()
                    .input_commitment
                    .clone();

                assert_eq!(
                    &code_commitment,
                    v3_mpc_commitments.get_code_commit_ref(is_mask, is_left_eye)
                );
            }

            // v3_proof.insert_aux_public_data(aux_mle, is_mask, is_left_eye, circuit);
            let aux_data = if is_mask {
                v3_circuit_and_aux_data.get_mask_aux_data_ref().clone()
            } else {
                v3_circuit_and_aux_data.get_iris_aux_data_ref().clone()
            };

            let circuit_with_inputs = iriscode_ss_attach_aux_data::<
                _,
                { remainder_frontend::zk_iriscode_ss::parameters::BASE },
            >(circuit.clone(), aux_data)
            .unwrap();

            let mut verifiable_circuit = circuit_with_inputs
                .gen_hyrax_verifiable_circuit::<Bn256Point>()
                .unwrap();

            verifiable_circuit
                .set_commitment_parameters(V3_INPUT_IMAGE_LAYER, IMAGE_COMMIT_LOG_NUM_COLS)
                .expect("Could not modify the verifier circuit commitment parameters");

            if let Err(err) =
                v3_proof.verify(is_mask, is_left_eye, &verifiable_circuit, commitment_hash)
            {
                println!("IC circuit verification failed with error: {err:#?}");
            } else {
                println!("IC circuit verification succeeded!!");
            }
        }
    }
}
